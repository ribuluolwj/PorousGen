//==============================================================================
//  WARNING!!  This file is overwritten by the Block Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  G:\RPWorkspace\PorousGen\UG_Dev\Application\Porous2D.hpp
//
//        This file was generated by the NX Block Styler
//        Created by: RenPeng
//              Version: NX 1919
//              Date: 12-09-2020  (Format: mm-dd-yyyy)
//              Time: 16:47
//
//==============================================================================

#ifndef POROUS2D_H_INCLUDED
#define POROUS2D_H_INCLUDED

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include <iostream>
#include <cmath>
#include <ctime>
#include "HuNXOpen.h"
#include "uf_all.h"
//#include <Windows.h>
//#include <wincrypt.h>
#include <random>
//------------------------------------------------------------------------------
//Bit Option for Property: SnapPointTypesEnabled
//------------------------------------------------------------------------------
#define              SnapPointTypesEnabled_UserDefined (1 << 0);
#define                 SnapPointTypesEnabled_Inferred (1 << 1);
#define           SnapPointTypesEnabled_ScreenPosition (1 << 2);
#define                 SnapPointTypesEnabled_EndPoint (1 << 3);
#define                 SnapPointTypesEnabled_MidPoint (1 << 4);
#define             SnapPointTypesEnabled_ControlPoint (1 << 5);
#define             SnapPointTypesEnabled_Intersection (1 << 6);
#define                SnapPointTypesEnabled_ArcCenter (1 << 7);
#define            SnapPointTypesEnabled_QuadrantPoint (1 << 8);
#define            SnapPointTypesEnabled_ExistingPoint (1 << 9);
#define             SnapPointTypesEnabled_PointonCurve (1 <<10);
#define           SnapPointTypesEnabled_PointonSurface (1 <<11);
#define         SnapPointTypesEnabled_PointConstructor (1 <<12);
#define     SnapPointTypesEnabled_TwocurveIntersection (1 <<13);
#define             SnapPointTypesEnabled_TangentPoint (1 <<14);
#define                    SnapPointTypesEnabled_Poles (1 <<15);
#define         SnapPointTypesEnabled_BoundedGridPoint (1 <<16);
#define         SnapPointTypesEnabled_FacetVertexPoint (1 <<17);
#define            SnapPointTypesEnabled_DefiningPoint (1 <<18);
//------------------------------------------------------------------------------
//Bit Option for Property: SnapPointTypesOnByDefault
//------------------------------------------------------------------------------
#define          SnapPointTypesOnByDefault_UserDefined (1 << 0);
#define             SnapPointTypesOnByDefault_Inferred (1 << 1);
#define       SnapPointTypesOnByDefault_ScreenPosition (1 << 2);
#define             SnapPointTypesOnByDefault_EndPoint (1 << 3);
#define             SnapPointTypesOnByDefault_MidPoint (1 << 4);
#define         SnapPointTypesOnByDefault_ControlPoint (1 << 5);
#define         SnapPointTypesOnByDefault_Intersection (1 << 6);
#define            SnapPointTypesOnByDefault_ArcCenter (1 << 7);
#define        SnapPointTypesOnByDefault_QuadrantPoint (1 << 8);
#define        SnapPointTypesOnByDefault_ExistingPoint (1 << 9);
#define         SnapPointTypesOnByDefault_PointonCurve (1 <<10);
#define       SnapPointTypesOnByDefault_PointonSurface (1 <<11);
#define     SnapPointTypesOnByDefault_PointConstructor (1 <<12);
#define SnapPointTypesOnByDefault_TwocurveIntersection (1 <<13);
#define         SnapPointTypesOnByDefault_TangentPoint (1 <<14);
#define                SnapPointTypesOnByDefault_Poles (1 <<15);
#define     SnapPointTypesOnByDefault_BoundedGridPoint (1 <<16);
#define     SnapPointTypesOnByDefault_FacetVertexPoint (1 <<17);
#define        SnapPointTypesOnByDefault_DefiningPoint (1 <<18);
//------------------------------------------------------------------------------
// Namespaces needed for following template
//------------------------------------------------------------------------------
using namespace std;
using namespace NXOpen;
using namespace NXOpen::BlockStyler;

class DllExport Porous2D
{
    // class members
public:
    static Session *theSession;
    static UI *theUI;
    Porous2D();
    ~Porous2D();
    int Show();
    
    //----------------------- BlockStyler Callback Prototypes ---------------------
    // The following member function prototypes define the callbacks 
    // specified in your BlockStyler dialog.  The empty implementation
    // of these prototypes is provided in the Porous2D.cpp file. 
    // You are REQUIRED to write the implementation for these functions.
    //------------------------------------------------------------------------------
    void initialize_cb();
    void dialogShown_cb();
    int apply_cb();
    int ok_cb();
    int update_cb(NXOpen::BlockStyler::UIBlock* block);
    PropertyList* GetBlockProperties(const char *blockID);

    //Add by RP
    //--Set porous sheet global object
    NXOpen::NXObject* porousSheetObject;
    //--Set porous bodys
    NXOpen::Body* porousBodys;
    std::vector<NXOpen::Body*> porousBodysCollector;
    //--Set AssociativeArc global parameters
    std::vector<NXOpen::NXObject*> particleObject;
    NXOpen::Features::AssociativeArc* arcFeature;
    std::vector<NXOpen::Features::AssociativeArc*>arcFeatureCollector;
    //--Set particle center point global parameters
    std::vector<NXOpen::Point*>centerPointCollector;
    //--Set helpPoint used in TrimSheetBodys to get curve feature
    NXOpen::Point3d helpPoint;
    std::vector<NXOpen::Point3d>helpPointCollector;

    void GenPorousSheet(NXOpen::Part* workPart);
    void GenParticleCurve(NXOpen::Part* workPart);
    //double Porous2D::GetRandomFloatNumber(double max, double min, double particleSize);
    double Porous2D::GetRandomParticles(NXOpen::Part* workPart, string direction);
    void TrimPorousSheet(NXOpen::Part* workPart);



private:
    const char* theDlxFileName;
    NXOpen::BlockStyler::BlockDialog* theDialog;
    NXOpen::BlockStyler::Group* groupSheetStartPoint;// Block type: Group
    NXOpen::BlockStyler::SpecifyPoint* pointSheetStart;// Block type: Specify Point
    NXOpen::BlockStyler::Group* groupShape;// Block type: Group
    NXOpen::BlockStyler::Enumeration* enumParticleShape;// Block type: Enumeration
    NXOpen::BlockStyler::Group* groupGenMethod;// Block type: Group
    NXOpen::BlockStyler::Enumeration* enumGenMethod;// Block type: Enumeration
    NXOpen::BlockStyler::Group* groupSize;// Block type: Group
    NXOpen::BlockStyler::ExpressionBlock* expressionFaceLength;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionFaceWidth;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionParticleSize;// Block type: Expression
    NXOpen::BlockStyler::Group* groupParticle;// Block type: Group
    NXOpen::BlockStyler::TabControl* tabControl;// Block type: Tabs Page
    NXOpen::BlockStyler::Group* tabPage;
    NXOpen::BlockStyler::IntegerBlock* integerParticleNumber;// Block type: Integer
    NXOpen::BlockStyler::DoubleBlock* doublePorousRatio;// Block type: Double
    NXOpen::BlockStyler::Toggle* toggleUsePorousRatio;// Block type: Toggle
    NXOpen::BlockStyler::Group* tabPageVoronoi;
    NXOpen::BlockStyler::IntegerBlock* integerBSplineOrder;// Block type: Integer
    NXOpen::BlockStyler::IntegerBlock* integerScaleRatio;// Block type: Integer
    NXOpen::BlockStyler::Toggle* toggleScale;// Block type: Toggle
    NXOpen::BlockStyler::Group* tabPage1;
    NXOpen::BlockStyler::ExpressionBlock* expressionRowGap;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionColumGap;// Block type: Expression
    NXOpen::BlockStyler::Group* group;// Block type: Group
    NXOpen::BlockStyler::Button* buttonGenSheet;// Block type: Button
    NXOpen::BlockStyler::Button* buttonGenParticle;// Block type: Button
    NXOpen::BlockStyler::Button* buttonTrimParticle;// Block type: Button
    NXOpen::BlockStyler::Button* buttonOnekeyGen;// Block type: Button
    
};

//Genarate porous sheets
void Porous2D::GenPorousSheet(NXOpen::Part* workPart)
{
//--4 points creat plane
    //Initialize FourPointSurfaceBuilder
    NXOpen::FourPointSurfaceBuilder* fourPointSurfaceBuilder1;
    fourPointSurfaceBuilder1 = workPart->Bodies()->CreateFourPointSurfaceBuilder();
    //Create set points of surface
    //----Set setpoint1
    NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
    fourPointSurfaceBuilder1->SetPoint1(setPoint1);
    double x0 = setPoint1->Coordinates().X;
    double y0 = setPoint1->Coordinates().Y;
    double z0 = setPoint1->Coordinates().Z;
    //----Set setpoint2
    NXOpen::Scalar* scalar21;
    scalar21 = workPart->Scalars()->CreateScalar(x0 + expressionFaceLength->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar22;
    scalar22 = workPart->Scalars()->CreateScalar(y0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar23;
    scalar23 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Point* setPoint2 = workPart->Points()->CreatePoint(scalar21, scalar22, scalar23, NXOpen::SmartObject::UpdateOptionWithinModeling);
    fourPointSurfaceBuilder1->SetPoint2(setPoint2);
    //----Set setpoint3
    NXOpen::Scalar* scalar31;
    scalar31 = workPart->Scalars()->CreateScalar(x0 + expressionFaceLength->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar32;
    scalar32 = workPart->Scalars()->CreateScalar(y0 + expressionFaceWidth->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar33;
    scalar33 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Point* setPoint3 = workPart->Points()->CreatePoint(scalar31, scalar32, scalar33, NXOpen::SmartObject::UpdateOptionWithinModeling);
    fourPointSurfaceBuilder1->SetPoint3(setPoint3);
    //----Set setpoint4
    NXOpen::Scalar* scalar41;
    scalar41 = workPart->Scalars()->CreateScalar(x0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar42;
    scalar42 = workPart->Scalars()->CreateScalar(y0 + expressionFaceWidth->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar43;
    scalar43 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Point* setPoint4 = workPart->Points()->CreatePoint(scalar41, scalar42, scalar43, NXOpen::SmartObject::UpdateOptionWithinModeling);
    fourPointSurfaceBuilder1->SetPoint4(setPoint4);
    //Create surface object
    NXOpen::NXObject* nXObjectSheet;
    nXObjectSheet = fourPointSurfaceBuilder1->Commit();
    //Pass to global parameters
    //----Get trim taget object
    Porous2D::porousSheetObject = nXObjectSheet;
    //----Get trim taget sheet bodies
    Porous2D::porousBodys = dynamic_cast<NXOpen::Body*>(nXObjectSheet);
    Porous2D::porousBodysCollector.push_back(Porous2D::porousBodys);
    //Free memory
    fourPointSurfaceBuilder1->Destroy();
}

//Genarate particles curves
void Porous2D::GenParticleCurve(NXOpen::Part* workPart)
{
//--Create particle boundary curves
    //Create circle curve as particles
    //Generate random seed
    std::srand((unsigned)std::time(0));
    unsigned int currentParticleNum = 0;
    //Create circle center point
    NXOpen::Point3d origin1(0.0, 0.0, 0.0);
    NXOpen::Vector3d normal1(0.0, 0.0, 1.0);
    NXOpen::Plane* plane1;
    plane1 = workPart->Planes()->CreatePlane(origin1, normal1, NXOpen::SmartObject::UpdateOptionWithinModeling);
    //Initialize generation method string
    std::string rd = "Random";
    std::string sq = "Square";
    std::string hx = "Hexagon";
    std::string vo = "Voronoi";
    NXOpen::NXString genMethod = Porous2D::enumGenMethod->ValueAsString();
    NXOpen::NXString randomMethod(rd, NXString::Locale);
    NXOpen::NXString squareMethod(sq, NXString::Locale);
    NXOpen::NXString hexagonMethod(hx, NXString::Locale);
    NXOpen::NXString voronoiMethod(vo, NXString::Locale);
    //Judge particle genaration method
    if ((std::string)genMethod.GetText() == (std::string)randomMethod.GetText())
    {
        //Judge particle shape
        if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Circle")
        {
            //Generate circle particle curves
            while (currentParticleNum < integerParticleNumber->Value())
            {
                //Initialize AssociativeArcBuiler
                NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                //Get random particles' center points 
                //----Get sheet start point's coordinate
                NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
                double x0 = setPoint1->Coordinates().X;
                double y0 = setPoint1->Coordinates().Y;
                double z0 = setPoint1->Coordinates().Z;
                //----Create random circle center points
                NXOpen::Scalar* scalarX1(NULL);
                scalarX1 = workPart->Scalars()->CreateScalar(GetRandomParticles(workPart, "x"), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Scalar* scalarY1(NULL);
                scalarY1 = workPart->Scalars()->CreateScalar(GetRandomParticles(workPart, "y"), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Scalar* scalarZ1(NULL);
                scalarZ1 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Point* circleCorePoint1;
                circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                centerPointCollector.push_back(circleCorePoint1);
                //Set AssociativeArcBuilder parameters
                //----Create helpPoints for trim section
                helpPoint = { circleCorePoint1->Coordinates().X + expressionParticleSize->Value() / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                helpPointCollector.push_back(helpPoint);
                //----Set circle curves' genaration plane
                NXOpen::Vector3d Vector1;
                Vector1 = { 0.0, 0.0, 1.0 };
                //----Open switch to set plane normal direction
                NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                //----Set AssociativeArcBuilder required parameters
                associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                associativeArcBuilder1->Diameter()->SetValue(expressionParticleSize->Value());
                associativeArcBuilder1->Limits()->SetFullCircle(true);
                //Create circle particle curves
                NXOpen::NXObject* nXObjectCircle;
                nXObjectCircle = associativeArcBuilder1->Commit();
                //Pass to global parameters
                //----Get particle curves' objects
                particleObject.push_back(nXObjectCircle);
                //----Get particle curves' features
                arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                arcFeatureCollector.push_back(arcFeature);
                //Free memory
                associativeArcBuilder1->Destroy();
                //Update particle number
                currentParticleNum++;
            }
        }
        else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
        {
            while (currentParticleNum < integerParticleNumber->Value())
            {
                //Update particle number
                currentParticleNum++;
            }
        }
        else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
        {
            while (currentParticleNum < integerParticleNumber->Value())
            {
                //Update particle number
                currentParticleNum++;
            }
        }      
    }
    else if ((std::string)genMethod.GetText() == (std::string)squareMethod.GetText())
    {
        //Judge particle shape
        if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Circle")
        {
            //----Get sheet start point's coordinate
            NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
            double x0 = setPoint1->Coordinates().X;
            double y0 = setPoint1->Coordinates().Y;
            double z0 = setPoint1->Coordinates().Z;
            //----Get sheet center point's coordinate
            NXOpen::Point* pointSheetCenter;
            double xSheetCenter = setPoint1->Coordinates().X + expressionFaceLength->Value() / 2.0;
            double ySheetCenter = setPoint1->Coordinates().Y + expressionFaceWidth->Value() / 2.0;
            double zSheetCenter = setPoint1->Coordinates().Z;
            //----Compute max colume and row
            int squareRow = 0;
            int particleModifiedNumber = integerParticleNumber->Value();
            int rowMax = floor(expressionFaceWidth->Value() / expressionParticleSize->Value());
            int columMax = floor(expressionFaceLength->Value() / expressionParticleSize->Value());
            if (floor(integerParticleNumber->Value() / columMax) > rowMax)
            {
                uc1601("Error! Wrong particle number", 1);
            }
            else if (integerParticleNumber->Value() % columMax == 0)
            {
                squareRow = integerParticleNumber->Value() / columMax;
            }
            else if ( floor(integerParticleNumber->Value() / columMax) == rowMax)
            {
                squareRow = rowMax;
                particleModifiedNumber = squareRow * columMax;
            }
            else
            {
                squareRow = floor(integerParticleNumber->Value() / columMax) + 1;
                particleModifiedNumber = squareRow * columMax;
            }
            //Get first point's coordination

            //Generate circle particle curves
            for (int i = 0; i < squareRow; i++)
            {
                for (int j = 0; j < rowMax; j++)
                {
                    //Initialize AssociativeArcBuiler
                    NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                    NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                    associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                    //Get particles' center points 


                    //----Create  circle center points


                    NXOpen::Scalar* scalarX1(NULL);
                    scalarX1 = workPart->Scalars()->CreateScalar(GetRandomParticles(workPart, "x"), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarY1(NULL);
                    scalarY1 = workPart->Scalars()->CreateScalar(GetRandomParticles(workPart, "y"), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarZ1(NULL);
                    scalarZ1 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Point* circleCorePoint1;
                    circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    centerPointCollector.push_back(circleCorePoint1);
                    //Set AssociativeArcBuilder parameters
                    //----Create helpPoints for trim section
                    helpPoint = { circleCorePoint1->Coordinates().X + expressionParticleSize->Value() / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                    helpPointCollector.push_back(helpPoint);
                    //----Set circle curves' genaration plane
                    NXOpen::Vector3d Vector1;
                    Vector1 = { 0.0, 0.0, 1.0 };
                    //----Open switch to set plane normal direction
                    NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                    planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                    associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                    //----Set AssociativeArcBuilder required parameters
                    associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                    associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                    associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                    associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                    associativeArcBuilder1->Diameter()->SetValue(expressionParticleSize->Value());
                    associativeArcBuilder1->Limits()->SetFullCircle(true);
                    //Create circle particle curves
                    NXOpen::NXObject* nXObjectCircle;
                    nXObjectCircle = associativeArcBuilder1->Commit();
                    //Pass to global parameters
                    //----Get particle curves' objects
                    particleObject.push_back(nXObjectCircle);
                    //----Get particle curves' features
                    arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                    arcFeatureCollector.push_back(arcFeature);
                    //Free memory
                    associativeArcBuilder1->Destroy();
                }
            }
            //while (currentParticleNum < particleModifiedNumber)
            //{
            //    
            //    
            //    //Update particle number
            //    currentParticleNum++;
            //}
        }
    }
    else if ((std::string)genMethod.GetText() == (std::string)hexagonMethod.GetText())
    {

        while (currentParticleNum < integerParticleNumber->Value())
        {
            //Update particle number
            currentParticleNum++;
        }
    }
    else if ((std::string)genMethod.GetText() == (std::string)voronoiMethod.GetText())
    {
        while (currentParticleNum < integerParticleNumber->Value())
        {
            //Update particle number
            currentParticleNum++;
        }
    }
    plane1->DestroyPlane();
}

//Genarate random x or y in porous sheet zone
double Porous2D::GetRandomParticles(NXOpen::Part* workPart,string direction)
{
    std::random_device random;
    std::mt19937_64 mt(random());
    NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
    double x0 = setPoint1->Coordinates().X;
    double y0 = setPoint1->Coordinates().Y;
    double z0 = setPoint1->Coordinates().Z;
    double particleSize = expressionParticleSize->Value();
    double xMax = x0 + expressionFaceLength->Value();
    double yMax = y0 + expressionFaceWidth->Value();
    if (direction == "x")
    {
        return ((double)mt() / RAND_MAX) * (xMax - x0 - particleSize) + x0 + particleSize / 2.0;
    }
    else if(direction == "y")
    {
        return ((double)mt() / RAND_MAX) * (yMax - y0 - particleSize) + y0 + particleSize / 2.0;
    }
    else
    {
        uc1601("Error: Wrong direction in particle curve genaration!",1);
    }
}

//Trim sheet to get porous
void Porous2D::TrimPorousSheet(NXOpen::Part* workPart)
{
    //Trim sheet to get porous
    //Initialize parameters
    unsigned int currentParticleNum = 0;
    std::vector<NXOpen::Features::Feature*> features1(1);
    std::vector<NXOpen::SelectionIntentRule*> rules1(1);
    NXOpen::CurveFeatureRule* curveFeatureRule1;
    NXOpen::NXObject* nullNXOpen_NXObject(NULL);
    //Set loop
    while (currentParticleNum < integerParticleNumber->Value())
    {
        //Initialize TrimSheetBuilder
        NXOpen::Features::Feature* nullNXOpen_Features_Feature(NULL);
        NXOpen::Features::TrimSheetBuilder* trimSheetBuilder1;
        trimSheetBuilder1 = workPart->Features()->CreateTrimsheetBuilder(nullNXOpen_Features_Feature);
        trimSheetBuilder1->SetTolerance(0.001);
        trimSheetBuilder1->SetExtendBoundaryObject(true);
        //Set trim taget object
        trimSheetBuilder1->TargetBodies()->Add(Porous2D::porousBodys);
        //Set maintain region referrence point
        NXOpen::Point* point1;
        point1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
        NXOpen::RegionPoint* regionPoint1;
        regionPoint1 = workPart->CreateRegionPoint(point1, porousBodys);
        trimSheetBuilder1->Regions()->Append(regionPoint1);
        //Set trim section
        NXOpen::Section* section1;
        section1 = workPart->Sections()->CreateSection(0.00095, 0.001, 0.050000000000000003);
        //Set section as TrimSheetBuilder boundary
        trimSheetBuilder1->BoundaryObjects()->Add(section1);
        //----Add Features
        features1[0]=arcFeatureCollector[currentParticleNum];
        //----Set SelectionIntentRule
        curveFeatureRule1 = workPart->ScRuleFactory()->CreateRuleCurveFeature(features1);
        rules1[0]=curveFeatureRule1;
        //----Add rules to section
        section1->AddToSection(rules1, nullNXOpen_NXObject, nullNXOpen_NXObject, nullNXOpen_NXObject, helpPointCollector[currentParticleNum], NXOpen::Section::ModeCreate, false);
        //Trim sheet
        NXOpen::NXObject* nXObjectTrimPorousSheet;
        nXObjectTrimPorousSheet = trimSheetBuilder1->Commit();
        //Free memory
        trimSheetBuilder1->Destroy();
        //Update particle number
        currentParticleNum++;
    }
}

#endif //POROUS2D_H_INCLUDED
