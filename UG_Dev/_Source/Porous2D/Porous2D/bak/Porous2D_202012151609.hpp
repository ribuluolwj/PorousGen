//==============================================================================
//  WARNING!!  This file is overwritten by the Block Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  G:\RPWorkspace\PorousGen\UG_Dev\Application\Porous2D.hpp
//
//        This file was generated by the NX Block Styler
//        Created by: RenPeng
//              Version: NX 1919
//              Date: 12-12-2020  (Format: mm-dd-yyyy)
//              Time: 18:02
//
//==============================================================================

#ifndef POROUS2D_H_INCLUDED
#define POROUS2D_H_INCLUDED

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include <iostream>
#include <cmath>
#include <ctime>
#include <random>
#include "HuNXOpen.h"
#include "uf_all.h"


//------------------------------------------------------------------------------
//Bit Option for Property: SnapPointTypesEnabled
//------------------------------------------------------------------------------
#define              SnapPointTypesEnabled_UserDefined (1 << 0);
#define                 SnapPointTypesEnabled_Inferred (1 << 1);
#define           SnapPointTypesEnabled_ScreenPosition (1 << 2);
#define                 SnapPointTypesEnabled_EndPoint (1 << 3);
#define                 SnapPointTypesEnabled_MidPoint (1 << 4);
#define             SnapPointTypesEnabled_ControlPoint (1 << 5);
#define             SnapPointTypesEnabled_Intersection (1 << 6);
#define                SnapPointTypesEnabled_ArcCenter (1 << 7);
#define            SnapPointTypesEnabled_QuadrantPoint (1 << 8);
#define            SnapPointTypesEnabled_ExistingPoint (1 << 9);
#define             SnapPointTypesEnabled_PointonCurve (1 <<10);
#define           SnapPointTypesEnabled_PointonSurface (1 <<11);
#define         SnapPointTypesEnabled_PointConstructor (1 <<12);
#define     SnapPointTypesEnabled_TwocurveIntersection (1 <<13);
#define             SnapPointTypesEnabled_TangentPoint (1 <<14);
#define                    SnapPointTypesEnabled_Poles (1 <<15);
#define         SnapPointTypesEnabled_BoundedGridPoint (1 <<16);
#define         SnapPointTypesEnabled_FacetVertexPoint (1 <<17);
#define            SnapPointTypesEnabled_DefiningPoint (1 <<18);
//------------------------------------------------------------------------------
//Bit Option for Property: SnapPointTypesOnByDefault
//------------------------------------------------------------------------------
#define          SnapPointTypesOnByDefault_UserDefined (1 << 0);
#define             SnapPointTypesOnByDefault_Inferred (1 << 1);
#define       SnapPointTypesOnByDefault_ScreenPosition (1 << 2);
#define             SnapPointTypesOnByDefault_EndPoint (1 << 3);
#define             SnapPointTypesOnByDefault_MidPoint (1 << 4);
#define         SnapPointTypesOnByDefault_ControlPoint (1 << 5);
#define         SnapPointTypesOnByDefault_Intersection (1 << 6);
#define            SnapPointTypesOnByDefault_ArcCenter (1 << 7);
#define        SnapPointTypesOnByDefault_QuadrantPoint (1 << 8);
#define        SnapPointTypesOnByDefault_ExistingPoint (1 << 9);
#define         SnapPointTypesOnByDefault_PointonCurve (1 <<10);
#define       SnapPointTypesOnByDefault_PointonSurface (1 <<11);
#define     SnapPointTypesOnByDefault_PointConstructor (1 <<12);
#define SnapPointTypesOnByDefault_TwocurveIntersection (1 <<13);
#define         SnapPointTypesOnByDefault_TangentPoint (1 <<14);
#define                SnapPointTypesOnByDefault_Poles (1 <<15);
#define     SnapPointTypesOnByDefault_BoundedGridPoint (1 <<16);
#define     SnapPointTypesOnByDefault_FacetVertexPoint (1 <<17);
#define        SnapPointTypesOnByDefault_DefiningPoint (1 <<18);
//------------------------------------------------------------------------------
// Namespaces needed for following template
//------------------------------------------------------------------------------
using namespace std;
using namespace NXOpen;
using namespace NXOpen::BlockStyler;

class DllExport Porous2D
{
    // class members
public:
    static Session *theSession;
    static UI *theUI;
    Porous2D();
    ~Porous2D();
    int Show();
    
    //----------------------- BlockStyler Callback Prototypes ---------------------
    // The following member function prototypes define the callbacks 
    // specified in your BlockStyler dialog.  The empty implementation
    // of these prototypes is provided in the Porous2D.cpp file. 
    // You are REQUIRED to write the implementation for these functions.
    //------------------------------------------------------------------------------
    void initialize_cb();
    void dialogShown_cb();
    int apply_cb();
    int ok_cb();
    int update_cb(NXOpen::BlockStyler::UIBlock* block);
    PropertyList* GetBlockProperties(const char *blockID);

    //Add for PorousTools addon by RP
    //--Set porous sheet global object
    NXOpen::NXObject* porousSheetObject;
    //--Set porous bodys
    NXOpen::Body* porousBodys;
    std::vector<NXOpen::Body*> porousBodysCollector;
    //--Set AssociativeArc global parameters
    std::vector<NXOpen::NXObject*> particleObject;
    NXOpen::Features::AssociativeArc* arcFeature;
    std::vector<NXOpen::Features::AssociativeArc*>arcFeatureCollector;
    //--Set particle center point global parameters
    std::vector<NXOpen::Point*>centerPointCollector;
    //--Set helpPoint used in TrimSheetBodys to get curve feature
    NXOpen::Point3d helpPoint;
    std::vector<NXOpen::Point3d>helpPointCollector;
    int particleNumber;

    void GenPorousSheet(NXOpen::Part* workPart);
    void GenParticleCurve(NXOpen::Part* workPart);
    double Porous2D::GetRandomCoordinate(NXOpen::Part* workPart, string direction);
    void TrimPorousSheet(NXOpen::Part* workPart);

    void GenRandom(NXOpen::Part* workPart);
    void GenSquare(NXOpen::Part* workPart);
    void GenHexagon(NXOpen::Part* workPart);
    void GenVoronoi(NXOpen::Part* workPart);
    
private:
    const char* theDlxFileName;
    NXOpen::BlockStyler::BlockDialog* theDialog;
    NXOpen::BlockStyler::Group* groupSheetStartPoint;// Block type: Group
    NXOpen::BlockStyler::SpecifyPoint* pointSheetStart;// Block type: Specify Point
    NXOpen::BlockStyler::Group* groupShape;// Block type: Group
    NXOpen::BlockStyler::Enumeration* enumParticleShape;// Block type: Enumeration
    NXOpen::BlockStyler::Group* groupGenMethod;// Block type: Group
    NXOpen::BlockStyler::Enumeration* enumGenMethod;// Block type: Enumeration
    NXOpen::BlockStyler::Group* groupSize;// Block type: Group
    NXOpen::BlockStyler::ExpressionBlock* expressionFaceLength;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionFaceWidth;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionParticleSize;// Block type: Expression
    NXOpen::BlockStyler::Group* groupParticle;// Block type: Group
    NXOpen::BlockStyler::TabControl* tabControl;// Block type: Tabs Page
    NXOpen::BlockStyler::Group* tabPage;
    NXOpen::BlockStyler::IntegerBlock* integerParticleNumber;// Block type: Integer
    NXOpen::BlockStyler::DoubleBlock* doublePorousRatio;// Block type: Double
    NXOpen::BlockStyler::Toggle* toggleUsePorousRatio;// Block type: Toggle
    NXOpen::BlockStyler::Group* tabPageVoronoi;
    NXOpen::BlockStyler::IntegerBlock* integerBSplineOrder;// Block type: Integer
    NXOpen::BlockStyler::IntegerBlock* integerScaleRatio;// Block type: Integer
    NXOpen::BlockStyler::Toggle* toggleScale;// Block type: Toggle
    NXOpen::BlockStyler::Group* tabPage1;
    NXOpen::BlockStyler::ExpressionBlock* expressionRowGap;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionColumGap;// Block type: Expression
    NXOpen::BlockStyler::Group* group;// Block type: Group
    NXOpen::BlockStyler::Button* buttonGenSheet;// Block type: Button
    NXOpen::BlockStyler::Button* buttonGenParticle;// Block type: Button
    NXOpen::BlockStyler::Button* buttonTrimParticle;// Block type: Button
    NXOpen::BlockStyler::Button* buttonOnekeyGen;// Block type: Button 
};

//Genarate porous sheets
void Porous2D::GenPorousSheet(NXOpen::Part* workPart)
{
    //Four points creat plane
    //Initialize FourPointSurfaceBuilder
    NXOpen::FourPointSurfaceBuilder* fourPointSurfaceBuilder1;
    fourPointSurfaceBuilder1 = workPart->Bodies()->CreateFourPointSurfaceBuilder();
    //Create set points of surface
    //----Set setpoint1
    NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
    fourPointSurfaceBuilder1->SetPoint1(setPoint1);
    double x0 = setPoint1->Coordinates().X;
    double y0 = setPoint1->Coordinates().Y;
    double z0 = setPoint1->Coordinates().Z;
    //----Set setpoint2
    NXOpen::Scalar* scalar21;
    scalar21 = workPart->Scalars()->CreateScalar(x0 + expressionFaceLength->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar22;
    scalar22 = workPart->Scalars()->CreateScalar(y0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar23;
    scalar23 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Point* setPoint2 = workPart->Points()->CreatePoint(scalar21, scalar22, scalar23, NXOpen::SmartObject::UpdateOptionWithinModeling);
    fourPointSurfaceBuilder1->SetPoint2(setPoint2);
    //----Set setpoint3
    NXOpen::Scalar* scalar31;
    scalar31 = workPart->Scalars()->CreateScalar(x0 + expressionFaceLength->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar32;
    scalar32 = workPart->Scalars()->CreateScalar(y0 + expressionFaceWidth->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar33;
    scalar33 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Point* setPoint3 = workPart->Points()->CreatePoint(scalar31, scalar32, scalar33, NXOpen::SmartObject::UpdateOptionWithinModeling);
    fourPointSurfaceBuilder1->SetPoint3(setPoint3);
    //----Set setpoint4
    NXOpen::Scalar* scalar41;
    scalar41 = workPart->Scalars()->CreateScalar(x0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar42;
    scalar42 = workPart->Scalars()->CreateScalar(y0 + expressionFaceWidth->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Scalar* scalar43;
    scalar43 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
    NXOpen::Point* setPoint4 = workPart->Points()->CreatePoint(scalar41, scalar42, scalar43, NXOpen::SmartObject::UpdateOptionWithinModeling);
    fourPointSurfaceBuilder1->SetPoint4(setPoint4);
    //Create surface object
    NXOpen::NXObject* nXObjectSheet;
    nXObjectSheet = fourPointSurfaceBuilder1->Commit();
    //Pass to global parameters
    //----Get trim taget object
    Porous2D::porousSheetObject = nXObjectSheet;
    //----Get trim taget sheet bodies
    Porous2D::porousBodys = dynamic_cast<NXOpen::Body*>(nXObjectSheet);
    Porous2D::porousBodysCollector.push_back(Porous2D::porousBodys);
    //Free memory
    fourPointSurfaceBuilder1->Destroy();
}

//Genarate particles curves
void Porous2D::GenParticleCurve(NXOpen::Part* workPart)
{
    //Create particle boundary curves
    //Create circle center point
    NXOpen::Point3d origin1(0.0, 0.0, 0.0);
    NXOpen::Vector3d normal1(0.0, 0.0, 1.0);
    NXOpen::Plane* plane1;
    plane1 = workPart->Planes()->CreatePlane(origin1, normal1, NXOpen::SmartObject::UpdateOptionWithinModeling);
    //Initialize generation method string
    std::string randomMethod = "Random";
    std::string squareMethod = "Square";
    std::string hexagonMethod = "Hexagon";
    std::string voronoiMethod = "Voronoi";
    NXOpen::NXString genMethod = Porous2D::enumGenMethod->ValueAsString();
    //Judge particle genaration method
    if ((std::string)genMethod.GetText() == randomMethod)
    {
        //Generate random particle curves
        GenRandom(workPart);
    }
    else if ((std::string)genMethod.GetText() == squareMethod)
    {
        //Generate square form particle porous
        GenSquare(workPart);
    }
    else if ((std::string)genMethod.GetText() == hexagonMethod)
    {
        //Generate hexagon form porous
        GenHexagon(workPart);
    }
    else if ((std::string)genMethod.GetText() == voronoiMethod)
    {
        //Generate Voronoi form porous
        GenVoronoi(workPart);
    }
    plane1->DestroyPlane();
}

//Genarate random x or y in porous sheet zone
double Porous2D::GetRandomCoordinate(NXOpen::Part* workPart, string direction)
{
    NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
    double x0 = setPoint1->Coordinates().X;
    double y0 = setPoint1->Coordinates().Y;
    double z0 = setPoint1->Coordinates().Z;
    double particleSize = Porous2D::expressionParticleSize->Value();
    double xMax = x0 + Porous2D::expressionFaceLength->Value();
    double yMax = y0 + Porous2D::expressionFaceWidth->Value();
    if (direction == "x")
    {
        return ((double)rand() / RAND_MAX) * (xMax - x0 - particleSize) + x0 + particleSize / 2.0;
    }
    else if (direction == "y")
    {
        return ((double)rand() / RAND_MAX) * (yMax - y0 - particleSize) + y0 + particleSize / 2.0;
    }
    else
    {
        uc1601("Error: Wrong direction in particle curve genaration!", 1);
    }
}

//Trim sheet to get porous 
void Porous2D::TrimPorousSheet(NXOpen::Part* workPart)
{
    //Trim sheet to get porous
    //Initialize parameters
    unsigned int currentParticleNum = 0;
    NXOpen::NXObject* nullNXOpen_NXObject(NULL);
    //Initialize TrimSheetBuilder
    NXOpen::Features::Feature* nullNXOpen_Features_Feature(NULL);
    NXOpen::Features::TrimSheetBuilder* trimSheetBuilder1;
    trimSheetBuilder1 = workPart->Features()->CreateTrimsheetBuilder(nullNXOpen_Features_Feature);
    trimSheetBuilder1->SetTolerance(0.001);
    trimSheetBuilder1->SetExtendBoundaryObject(true);
    //Set trim taget object
    trimSheetBuilder1->TargetBodies()->Add(Porous2D::porousBodys);
    //Set maintain region referrence point
    NXOpen::Point* point1;
    point1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
    NXOpen::RegionPoint* regionPoint1;
    regionPoint1 = workPart->CreateRegionPoint(point1, porousBodys);
    trimSheetBuilder1->Regions()->Append(regionPoint1);
    NXOpen::Direction* nullNXOpen_Direction(NULL);
    trimSheetBuilder1->ProjectionDirection()->SetProjectVector(nullNXOpen_Direction);
    //Set trim section
    NXOpen::Section* section1;
    section1 = workPart->Sections()->CreateSection(0.00095, 0.001, 0.050000000000000003);
    section1->SetAllowedEntityTypes(NXOpen::Section::AllowTypesOnlyCurves);
    //Set section as TrimSheetBuilder boundary
    trimSheetBuilder1->BoundaryObjects()->Add(section1);
    //----Set curve collector vector 
    std::vector<NXOpen::IBaseCurve*> curves1(Porous2D::particleNumber);
    std::vector<NXOpen::Arc*> arcSelected(Porous2D::particleNumber);
    //Set loop
    while (currentParticleNum < Porous2D::particleNumber)
    {
        arcSelected[currentParticleNum] = dynamic_cast<NXOpen::Arc*>(arcFeatureCollector[currentParticleNum]->FindObject("CURVE 1"));
        curves1[currentParticleNum] = arcSelected[currentParticleNum];
        //Update particle number
        currentParticleNum++;
    }
        section1->AllowSelfIntersection(true);
        NXOpen::CurveDumbRule* curveDumbRule1;
        curveDumbRule1 = workPart->ScRuleFactory()->CreateRuleBaseCurveDumb(curves1);
        //----Set SelectionIntentRule
        std::vector<NXOpen::SelectionIntentRule*> rules1(1);
        rules1[0] = curveDumbRule1;
        //----Add rules to section
        NXOpen::Point3d helpPointOrigin(0.0, 0.0, 0.0);
        section1->AddToSection(rules1, nullNXOpen_NXObject, nullNXOpen_NXObject, nullNXOpen_NXObject, helpPointOrigin, NXOpen::Section::ModeCreate, false);
        //Trim sheet
        NXOpen::NXObject* nXObjectTrimPorousSheet;
        nXObjectTrimPorousSheet = trimSheetBuilder1->Commit();
        //Free memory
        trimSheetBuilder1->Destroy();
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//Generate random form porous
void Porous2D::GenRandom(NXOpen::Part* workPart)
{
    //Generate random seed
    std::srand((unsigned)std::time(0));
    unsigned int currentParticleNum = 0;
    Porous2D::particleNumber = Porous2D::integerParticleNumber->Value();
    //Judge particle shape
    if ((std::string)(Porous2D::enumParticleShape->ValueAsString()).GetText() == "Circle")
    {
        //Create circle center point
        //Generate circle particle curves
        while (currentParticleNum < Porous2D::particleNumber)
        {
            //Initialize AssociativeArcBuiler
            NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
            NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
            associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
            //Get random particles' center points 
            //----Get sheet start point's coordinate
            NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
            double x0 = setPoint1->Coordinates().X;
            double y0 = setPoint1->Coordinates().Y;
            double z0 = setPoint1->Coordinates().Z;
            //----Create random circle center points
            NXOpen::Scalar* scalarX1(NULL);
            scalarX1 = workPart->Scalars()->CreateScalar(GetRandomCoordinate(workPart, "x"), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
            NXOpen::Scalar* scalarY1(NULL);
            scalarY1 = workPart->Scalars()->CreateScalar(GetRandomCoordinate(workPart, "y"), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
            NXOpen::Scalar* scalarZ1(NULL);
            scalarZ1 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
            NXOpen::Point* circleCorePoint1;
            circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
            Porous2D::centerPointCollector.push_back(circleCorePoint1);
            //Set AssociativeArcBuilder parameters
            //----Create helpPoints for trim section
            Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + Porous2D::expressionParticleSize->Value() / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
            Porous2D::helpPointCollector.push_back(helpPoint);
            //----Set circle curves' genaration plane
            NXOpen::Vector3d Vector1;
            Vector1 = { 0.0, 0.0, 1.0 };
            //----Open switch to set plane normal direction
            NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
            planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
            associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
            //----Set AssociativeArcBuilder required parameters
            associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
            associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
            associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
            associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
            associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionParticleSize->Value());
            associativeArcBuilder1->Limits()->SetFullCircle(true);
            //Create circle particle curves
            NXOpen::NXObject* nXObjectCircle;
            nXObjectCircle = associativeArcBuilder1->Commit();
            //Pass to global parameters
            //----Get particle curves' objects
            Porous2D::particleObject.push_back(nXObjectCircle);
            //----Get particle curves' features
            Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
            Porous2D::arcFeatureCollector.push_back(arcFeature);
            //Free memory
            associativeArcBuilder1->Destroy();
            //Update particle number
            currentParticleNum++;
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
    {
        while (currentParticleNum < Porous2D::particleNumber)
        {
            //Update particle number
            currentParticleNum++;
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
    {
        while (currentParticleNum < Porous2D::particleNumber)
        {
            //Update particle number
            currentParticleNum++;
        }
    }
}

//Generate square form porous
void Porous2D::GenSquare(NXOpen::Part* workPart) 
{
    //Judge particle shape
    if ((std::string)(Porous2D::enumParticleShape->ValueAsString()).GetText() == "Circle")
    {
        //----Get sheet start point's coordinate
        NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
        double x0 = setPoint1->Coordinates().X;
        double y0 = setPoint1->Coordinates().Y;
        double z0 = setPoint1->Coordinates().Z;
        //----Get sheet center point's coordinate
        double xSheetCenter = setPoint1->Coordinates().X + Porous2D::expressionFaceLength->Value() / 2.0;
        double ySheetCenter = setPoint1->Coordinates().Y + Porous2D::expressionFaceWidth->Value() / 2.0;
        double zSheetCenter = setPoint1->Coordinates().Z;
        //----Get porous zone boundary start point coordinary
        NXOpen::Point* pointPorousZoneStart;
        double xZoneStart = xSheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
        double yZoneStart = ySheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
        double zZoneStart = zSheetCenter;
        double zoneLength = min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
        //----Define local parameters
        double ratio = Porous2D::doublePorousRatio->Value();
        double diameter = Porous2D::expressionParticleSize->Value();
        //----Compute colum of particle square
        int rowSquare = floor(sqrt(zoneLength * zoneLength * (1.0 - ratio) * 4.0 / PI / (diameter * diameter)));
        Porous2D::particleNumber = rowSquare * rowSquare;
        double gap = zoneLength / (double)rowSquare - diameter;
        double boderGap = gap / 2.0;
        //----Compute start point coordination
        double xStartPoint = xZoneStart + boderGap + diameter / 2.0;
        double yStartPoint = yZoneStart + boderGap + diameter / 2.0;
        double zStartPoint = zZoneStart;
        //Generate circle particle curves
        for (int i = 0; i < rowSquare; i++)
        {
            for (int j = 0; j < rowSquare; j++)
            {
                //Initialize AssociativeArcBuiler
                NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                //Get particles' center points 
                //----Create  circle center points
                double x = xStartPoint + (diameter + gap) * j;
                double y = yStartPoint + (diameter + gap) * i;
                NXOpen::Scalar* scalarX1(NULL);
                scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Scalar* scalarY1(NULL);
                scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Scalar* scalarZ1(NULL);
                scalarZ1 = workPart->Scalars()->CreateScalar(zStartPoint, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Point* circleCorePoint1;
                circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                centerPointCollector.push_back(circleCorePoint1);
                //Set AssociativeArcBuilder parameters
                //----Create helpPoints for trim section
                Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                Porous2D::helpPointCollector.push_back(helpPoint);
                //----Set circle curves' genaration plane
                NXOpen::Vector3d Vector1;
                Vector1 = { 0.0, 0.0, 1.0 };
                //----Open switch to set plane normal direction
                NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                //----Set AssociativeArcBuilder required parameters
                associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionParticleSize->Value());
                associativeArcBuilder1->Limits()->SetFullCircle(true);
                //Create circle particle curves
                NXOpen::NXObject* nXObjectCircle;
                nXObjectCircle = associativeArcBuilder1->Commit();
                //Pass to global parameters
                //----Get particle curves' objects
                Porous2D::particleObject.push_back(nXObjectCircle);
                //----Get particle curves' features
                Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                Porous2D::arcFeatureCollector.push_back(arcFeature);
                //Free memory
                associativeArcBuilder1->Destroy();
            }
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
    {

    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
    {

    }
}

//Generate hexagon form porous
void Porous2D::GenHexagon(NXOpen::Part* workPart)
{
    //Judge particle shape
    if ((std::string)(Porous2D::enumParticleShape->ValueAsString()).GetText() == "Circle")
    {
        //----Get sheet start point's coordinate
        NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
        double x0 = setPoint1->Coordinates().X;
        double y0 = setPoint1->Coordinates().Y;
        double z0 = setPoint1->Coordinates().Z;
        //----Get sheet center point's coordinate
        double xSheetCenter = setPoint1->Coordinates().X + Porous2D::expressionFaceLength->Value() / 2.0;
        double ySheetCenter = setPoint1->Coordinates().Y + Porous2D::expressionFaceWidth->Value() / 2.0;
        double zSheetCenter = setPoint1->Coordinates().Z;
        //----Get porous zone boundary start point coordinary
        NXOpen::Point* pointPorousZoneStart;
        double xZoneStart = xSheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
        double yZoneStart = ySheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
        double zZoneStart = zSheetCenter;
        double zoneLength = min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
        //----Define local parameters
        double ratio = Porous2D::doublePorousRatio->Value();
        double diameter = Porous2D::expressionParticleSize->Value();
        //----Compute colum of particle hexagon
        int rowHexagon = floor(sqrt(zoneLength * zoneLength * (1.0 - ratio) * 4.0 / PI / (diameter * diameter)));
        Porous2D::particleNumber = rowHexagon * rowHexagon;
        double gap = 2.0 * zoneLength / (2.0 * (double)rowHexagon + 1.0) - diameter;
        double boderGap = gap / 2.0;
        double extraBoderGap = (diameter + gap) * ((2.0 - sqrt(3.0)) * rowHexagon / 2.0 + (sqrt(3.0) - 1.0) / 2.0) / 2.0;
        //Generate circle particle curves
        //Judge hexagon direction
        if (Porous2D::expressionFaceLength->Value() <= Porous2D::expressionFaceWidth->Value())
        {
            //Compute start point coordination
            double xStartPoint = xZoneStart + boderGap + diameter / 2.0;
            double yStartPoint = yZoneStart + boderGap + extraBoderGap + diameter / 2.0;
            double zStartPoint = zZoneStart;
            for (int i = 0; i < rowHexagon; i++)
            {
                for (int j = 0; j < rowHexagon; j++)
                {
                    //Initialize AssociativeArcBuiler
                    NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                    NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                    associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                    //Get particles' center points 
                    //----Create  circle center points
                    double x = xStartPoint + ((diameter + gap) / 2.0) * abs(sin((double)i / 2.0 * PI)) + (diameter + gap) * j;
                    double y = yStartPoint + sqrt(3.0) * (diameter + gap) / 2.0 * i;
                    NXOpen::Scalar* scalarX1(NULL);
                    scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarY1(NULL);
                    scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarZ1(NULL);
                    scalarZ1 = workPart->Scalars()->CreateScalar(zStartPoint, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Point* circleCorePoint1;
                    circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    centerPointCollector.push_back(circleCorePoint1);
                    //Set AssociativeArcBuilder parameters
                    //----Create helpPoints for trim section
                    Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                    Porous2D::helpPointCollector.push_back(helpPoint);
                    //----Set circle curves' genaration plane
                    NXOpen::Vector3d Vector1;
                    Vector1 = { 0.0, 0.0, 1.0 };
                    //----Open switch to set plane normal direction
                    NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                    planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                    associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                    //----Set AssociativeArcBuilder required parameters
                    associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                    associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                    associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                    associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                    associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionParticleSize->Value());
                    associativeArcBuilder1->Limits()->SetFullCircle(true);
                    //Create circle particle curves
                    NXOpen::NXObject* nXObjectCircle;
                    nXObjectCircle = associativeArcBuilder1->Commit();
                    //Pass to global parameters
                    //----Get particle curves' objects
                    Porous2D::particleObject.push_back(nXObjectCircle);
                    //----Get particle curves' features
                    Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                    Porous2D::arcFeatureCollector.push_back(arcFeature);
                    //Free memory
                    associativeArcBuilder1->Destroy();
                }
            }
        }
        else
        {
            //Compute start point coordination
            double xStartPoint = xZoneStart + boderGap + extraBoderGap + diameter / 2.0;
            double yStartPoint = yZoneStart + boderGap + diameter / 2.0;
            double zStartPoint = zZoneStart;
            for (int i = 0; i < rowHexagon; i++)
            {
                for (int j = 0; j < rowHexagon; j++)
                {
                    //Initialize AssociativeArcBuiler
                    NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                    NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                    associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                    //Get particles' center points 
                    //----Create  circle center points
                    double x = xStartPoint + sqrt(3.0) * (diameter + gap) / 2.0 * i;
                    double y = yStartPoint + ((diameter + gap) / 2.0) * abs(sin((double)i / 2.0 * PI)) + (diameter + gap) * j;
                    NXOpen::Scalar* scalarX1(NULL);
                    scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarY1(NULL);
                    scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarZ1(NULL);
                    scalarZ1 = workPart->Scalars()->CreateScalar(zStartPoint, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Point* circleCorePoint1;
                    circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    centerPointCollector.push_back(circleCorePoint1);
                    //Set AssociativeArcBuilder parameters
                    //----Create helpPoints for trim section
                    helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                    helpPointCollector.push_back(helpPoint);
                    //----Set circle curves' genaration plane
                    NXOpen::Vector3d Vector1;
                    Vector1 = { 0.0, 0.0, 1.0 };
                    //----Open switch to set plane normal direction
                    NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                    planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                    associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                    //----Set AssociativeArcBuilder required parameters
                    associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                    associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                    associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                    associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                    associativeArcBuilder1->Diameter()->SetValue(expressionParticleSize->Value());
                    associativeArcBuilder1->Limits()->SetFullCircle(true);
                    //Create circle particle curves
                    NXOpen::NXObject* nXObjectCircle;
                    nXObjectCircle = associativeArcBuilder1->Commit();
                    //Pass to global parameters
                    //----Get particle curves' objects
                    particleObject.push_back(nXObjectCircle);
                    //----Get particle curves' features
                    arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                    arcFeatureCollector.push_back(arcFeature);
                    //Free memory
                    associativeArcBuilder1->Destroy();
                }
            }
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
    {

    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
    {

    }
}

//Generate Voronoi form porous
void Porous2D::GenVoronoi(NXOpen::Part* workPart)
{

}
#endif //POROUS2D_H_INCLUDED
