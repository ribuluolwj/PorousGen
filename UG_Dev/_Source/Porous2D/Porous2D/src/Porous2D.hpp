//==============================================================================
//  WARNING!!  This file is overwritten by the Block Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  G:\RPWorkspace\PorousGen\UG_Dev\Application\Porous2D.hpp
//
//        This file was generated by the NX Block Styler
//        Created by: RenPeng
//              Version: NX 1919
//              Date: 12-15-2020  (Format: mm-dd-yyyy)
//              Time: 16:09
//
//==============================================================================

#ifndef POROUS2D_H_INCLUDED
#define POROUS2D_H_INCLUDED

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <cmath>
#include <ctime>
#include <random>
#include "../include/UG-Dev/HuNXOpen.h"
#include "../include/UG-Dev/uf_all.h"
#include "../include/Voronoi/Voronoi_all.h"
#include "../include/GlobalParameters.h"

//------------------------------------------------------------------------------
//Bit Option for Property: SnapPointTypesEnabled
//------------------------------------------------------------------------------
#define              SnapPointTypesEnabled_UserDefined (1 << 0);
#define                 SnapPointTypesEnabled_Inferred (1 << 1);
#define           SnapPointTypesEnabled_ScreenPosition (1 << 2);
#define                 SnapPointTypesEnabled_EndPoint (1 << 3);
#define                 SnapPointTypesEnabled_MidPoint (1 << 4);
#define             SnapPointTypesEnabled_ControlPoint (1 << 5);
#define             SnapPointTypesEnabled_Intersection (1 << 6);
#define                SnapPointTypesEnabled_ArcCenter (1 << 7);
#define            SnapPointTypesEnabled_QuadrantPoint (1 << 8);
#define            SnapPointTypesEnabled_ExistingPoint (1 << 9);
#define             SnapPointTypesEnabled_PointonCurve (1 <<10);
#define           SnapPointTypesEnabled_PointonSurface (1 <<11);
#define         SnapPointTypesEnabled_PointConstructor (1 <<12);
#define     SnapPointTypesEnabled_TwocurveIntersection (1 <<13);
#define             SnapPointTypesEnabled_TangentPoint (1 <<14);
#define                    SnapPointTypesEnabled_Poles (1 <<15);
#define         SnapPointTypesEnabled_BoundedGridPoint (1 <<16);
#define         SnapPointTypesEnabled_FacetVertexPoint (1 <<17);
#define            SnapPointTypesEnabled_DefiningPoint (1 <<18);
//------------------------------------------------------------------------------
//Bit Option for Property: SnapPointTypesOnByDefault
//------------------------------------------------------------------------------
#define          SnapPointTypesOnByDefault_UserDefined (1 << 0);
#define             SnapPointTypesOnByDefault_Inferred (1 << 1);
#define       SnapPointTypesOnByDefault_ScreenPosition (1 << 2);
#define             SnapPointTypesOnByDefault_EndPoint (1 << 3);
#define             SnapPointTypesOnByDefault_MidPoint (1 << 4);
#define         SnapPointTypesOnByDefault_ControlPoint (1 << 5);
#define         SnapPointTypesOnByDefault_Intersection (1 << 6);
#define            SnapPointTypesOnByDefault_ArcCenter (1 << 7);
#define        SnapPointTypesOnByDefault_QuadrantPoint (1 << 8);
#define        SnapPointTypesOnByDefault_ExistingPoint (1 << 9);
#define         SnapPointTypesOnByDefault_PointonCurve (1 <<10);
#define       SnapPointTypesOnByDefault_PointonSurface (1 <<11);
#define     SnapPointTypesOnByDefault_PointConstructor (1 <<12);
#define SnapPointTypesOnByDefault_TwocurveIntersection (1 <<13);
#define         SnapPointTypesOnByDefault_TangentPoint (1 <<14);
#define                SnapPointTypesOnByDefault_Poles (1 <<15);
#define     SnapPointTypesOnByDefault_BoundedGridPoint (1 <<16);
#define     SnapPointTypesOnByDefault_FacetVertexPoint (1 <<17);
#define        SnapPointTypesOnByDefault_DefiningPoint (1 <<18);
//------------------------------------------------------------------------------
// Namespaces needed for following template
//------------------------------------------------------------------------------
using namespace std;
using namespace NXOpen;
using namespace NXOpen::BlockStyler;

class DllExport Porous2D
{
    // class members
public:
    static Session *theSession;
    static UI *theUI;
    Porous2D();
    ~Porous2D();
    int Show();
    
    //----------------------- BlockStyler Callback Prototypes ---------------------
    // The following member function prototypes define the callbacks 
    // specified in your BlockStyler dialog.  The empty implementation
    // of these prototypes is provided in the Porous2D.cpp file. 
    // You are REQUIRED to write the implementation for these functions.
    //------------------------------------------------------------------------------
    void initialize_cb();
    void dialogShown_cb();
    int apply_cb();
    int ok_cb();
    int update_cb(NXOpen::BlockStyler::UIBlock* block);
    PropertyList* GetBlockProperties(const char *blockID);
    
    //Add for PorousTools addon by RP
    //--Set porous sheet global object
    NXOpen::NXObject* SheetObject;
    NXOpen::NXObject* porousSheetObject;
    //--Set porous bodys
    NXOpen::Body* sheetBodys;
    std::vector<NXOpen::Body*> sheetBodysCollector;
    //--Set AssociativeArc global parameters
    std::vector<NXOpen::NXObject*> particleObject;
    NXOpen::Features::AssociativeArc* arcFeature;
    std::vector<NXOpen::Features::AssociativeArc*>arcFeatureCollector;
    //--Set Spline global parameters
    NXOpen::Features::StudioSpline* splineFeature;
    std::vector<NXOpen::Features::StudioSpline*>splineFeatureCollector;
    //--Set particle center point global parameters
    std::vector<NXOpen::Point*>centerPointCollector;
    //--Set helpPoint used in TrimSheetBodys to get curve feature
    NXOpen::Point3d helpPoint;
    std::vector<NXOpen::Point3d>helpPointCollector;
    //--Set trimsheet body
    NXOpen::Body* porousBodys2D;
    std::vector<NXOpen::Body*> porousBodys2DCollector;

 //   enum Enumcomp {Clockwise,CounterClockwise};
    int particleNumber;
    int xNodeNumber;
    int yNodeNumber;

//    class Porous2D::compare {};
    double vertxMinX, vertxMinY;

//    sheet size parameters
    double sheetLength = 0;
    double sheetWidth = 0;
    //Set log file
    ofstream outf;

    void GenPorousSheet(NXOpen::Part* workPart);
    void GenParticleCurve(NXOpen::Part* workPart);
    double GetRandomCoordinate(NXOpen::Part* workPart, string direction);
    int GetRandomNode(NXOpen::Part* workPart, std::string direction);
    void TrimPorousSheet(NXOpen::Part* workPart);
    void GenPorous3D(NXOpen::Part* workPart);

    void GenRandom(NXOpen::Part* workPart);
    void GenSquare(NXOpen::Part* workPart);
    void GenHexagon(NXOpen::Part* workPart);
    void GenVoronoi(NXOpen::Part* workPart);
    void MeshSheet(NXOpen::Part* workPart);
//    void genVertexPoints(NXOpen::Part* workPart);
//    void Porous2D::genVertexPoints(Diagram* diagram);
//    void genVertexPoints(std::vector<double>* sitesX, std::vector<double>* sitesY);
    void genVertexPoints(std::vector<Point2>& sites, std::vector<Point2>& vertxStart,std::vector<Point2>&vertxEnd,std::vector<int>& edgeNumber);

//    bool vertxOrdered(const Point2& s1, const Point2& s2);
//    void orderVertxPoints(std::vector<Point2>& vertxPoints);
    //void orderVertxPoints(std::vector<Point2>& vertxPoints, double& vertxMinX,double& vertxMinY);

    std::vector<NXOpen::Point*> nodeMesh;
    std::vector<double>nodeMeshX;
    std::vector<double>nodeMeshY;

private:
    const char* theDlxFileName;
    NXOpen::BlockStyler::BlockDialog* theDialog;
    NXOpen::BlockStyler::Group* groupSheetStartPoint;// Block type: Group
    NXOpen::BlockStyler::SpecifyPoint* pointSheetStart;// Block type: Specify Point
    NXOpen::BlockStyler::Group* groupShape;// Block type: Group
    NXOpen::BlockStyler::Enumeration* enumParticleShape;// Block type: Enumeration
    NXOpen::BlockStyler::Group* groupGenMethod;// Block type: Group
    NXOpen::BlockStyler::Enumeration* enumGenMethod;// Block type: Enumeration
    NXOpen::BlockStyler::Toggle* toggleMeshRandom;// Block type: Toggle
    NXOpen::BlockStyler::Group* groupSize;// Block type: Group
    NXOpen::BlockStyler::TabControl* tabControl1;// Block type: Tabs Page
    NXOpen::BlockStyler::Group* tabPage2;
    NXOpen::BlockStyler::ExpressionBlock* expressionFaceLength;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionFaceWidth;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionParticleSize;// Block type: Expression
    NXOpen::BlockStyler::Group* tabPage3;
    NXOpen::BlockStyler::ExpressionBlock* expressionBasisWeight;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionDryContentFinal;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionDryContentNow;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionSheetLen;// Block type: Expression
    NXOpen::BlockStyler::Group* tabPage4;
    NXOpen::BlockStyler::ExpressionBlock* expressionLenDensity;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionCelLength;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionCelDiameter;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionLenWidRatio;// Block type: Expression
    NXOpen::BlockStyler::Toggle* togglePaper;// Block type: Toggle
    NXOpen::BlockStyler::ExpressionBlock* expressionComRatio;// Block type: Expression
    NXOpen::BlockStyler::Group* groupParticle;// Block type: Group
    NXOpen::BlockStyler::TabControl* tabControl;// Block type: Tabs Page
    NXOpen::BlockStyler::Group* tabPage;
    NXOpen::BlockStyler::IntegerBlock* integerParticleNumber;// Block type: Integer
    NXOpen::BlockStyler::DoubleBlock* doublePorousRatio;// Block type: Double
    NXOpen::BlockStyler::Toggle* toggleUsePorousRatio;// Block type: Toggle
    NXOpen::BlockStyler::Toggle* toggleOutFluid;// Block type: Toggle
    NXOpen::BlockStyler::Group* tabPageVoronoi;
    NXOpen::BlockStyler::IntegerBlock* integerBSplineOrder;// Block type: Integer
    NXOpen::BlockStyler::IntegerBlock* integerScaleRatio;// Block type: Integer
    NXOpen::BlockStyler::Toggle* toggleScale;// Block type: Toggle
    NXOpen::BlockStyler::Group* tabPage1;
    NXOpen::BlockStyler::ExpressionBlock* expressionRowGap;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionColumGap;// Block type: Expression
    NXOpen::BlockStyler::Group* groupOption;// Block type: Group
    NXOpen::BlockStyler::Button* buttonGenSheet;// Block type: Button
    NXOpen::BlockStyler::Button* buttonGenParticle;// Block type: Button
    NXOpen::BlockStyler::Button* buttonTrimParticle;// Block type: Button
    NXOpen::BlockStyler::Button* buttonGen3D;// Block type: Button
    NXOpen::BlockStyler::Button* buttonOnekeyGen;// Block type: Button
    NXOpen::BlockStyler::Group* groupSet;// Block type: Group
    NXOpen::BlockStyler::Toggle* togglePrintInfo;// Block type: Toggle
    NXOpen::BlockStyler::Toggle* toggleWriteFile;// Block type: Toggle
    NXOpen::BlockStyler::FolderSelection* nativeFolderBrowser0;// Block type: NativeFolderBrowser
};

//Generate porous sheets
void Porous2D::GenPorousSheet(NXOpen::Part* workPart)
{
    if (Porous2D::togglePaper->Value() == false)
    {
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t生成片体：普通方式\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t生成片体：普通方式" << endl;
        }
        //Four points creat plane
        //Initialize FourPointSurfaceBuilder
        NXOpen::FourPointSurfaceBuilder* fourPointSurfaceBuilder1;
        fourPointSurfaceBuilder1 = workPart->Bodies()->CreateFourPointSurfaceBuilder();
        //Create set points of surface
        //----Set setpoint1
        NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
        fourPointSurfaceBuilder1->SetPoint1(setPoint1);
        double x0 = setPoint1->Coordinates().X;
        double y0 = setPoint1->Coordinates().Y;
        double z0 = setPoint1->Coordinates().Z;
        //----Set setpoint2
        NXOpen::Scalar* scalar21;
        scalar21 = workPart->Scalars()->CreateScalar(x0 + expressionFaceLength->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar22;
        scalar22 = workPart->Scalars()->CreateScalar(y0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar23;
        scalar23 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint2 = workPart->Points()->CreatePoint(scalar21, scalar22, scalar23, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint2(setPoint2);
        //----Set setpoint3
        NXOpen::Scalar* scalar31;
        scalar31 = workPart->Scalars()->CreateScalar(x0 + expressionFaceLength->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar32;
        scalar32 = workPart->Scalars()->CreateScalar(y0 + expressionFaceWidth->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar33;
        scalar33 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint3 = workPart->Points()->CreatePoint(scalar31, scalar32, scalar33, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint3(setPoint3);
        //----Set setpoint4
        NXOpen::Scalar* scalar41;
        scalar41 = workPart->Scalars()->CreateScalar(x0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar42;
        scalar42 = workPart->Scalars()->CreateScalar(y0 + expressionFaceWidth->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar43;
        scalar43 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint4 = workPart->Points()->CreatePoint(scalar41, scalar42, scalar43, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint4(setPoint4);
        //Create surface object
        NXOpen::NXObject* nXObjectSheet;
        nXObjectSheet = fourPointSurfaceBuilder1->Commit();
        //Pass to global parameters
        //----Get trim taget object
        Porous2D::porousSheetObject = nXObjectSheet;
        //----Get trim taget sheet bodies
        Porous2D::sheetBodys = dynamic_cast<NXOpen::Body*>(nXObjectSheet);
        Porous2D::sheetBodysCollector.push_back(Porous2D::sheetBodys);
        //Free memory
        fourPointSurfaceBuilder1->Destroy();
    }
    else
    {
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t生成片体：纸幅方式\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t生成片体：普通方式" << endl;
        }
        //Four points creat plane
        //Initialize FourPointSurfaceBuilder
        NXOpen::FourPointSurfaceBuilder* fourPointSurfaceBuilder1;
        fourPointSurfaceBuilder1 = workPart->Bodies()->CreateFourPointSurfaceBuilder();
        //Create set points of surface
        //----Set setpoint1
        NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
        fourPointSurfaceBuilder1->SetPoint1(setPoint1);
        double x0 = setPoint1->Coordinates().X;
        double y0 = setPoint1->Coordinates().Y;
        double z0 = setPoint1->Coordinates().Z;
        //----Get sheet height
        Porous2D::sheetWidth = Porous2D::expressionBasisWeight->Value() /1000.0 * Porous2D::expressionDryContentFinal->Value() / 100.0\
            / (1.0 - Porous2D::doublePorousRatio->Value()) * (1.0 / 1.5e3 + (1.0 - Porous2D::expressionDryContentNow->Value() / 100.0) \
                / (Porous2D::expressionDryContentNow->Value() / 100.0) / 1e3) * 1000.0;
        Porous2D::sheetLength = Porous2D::sheetWidth * Porous2D::expressionLenWidRatio->Value();
        //----Set setpoint2
        NXOpen::Scalar* scalar21;
        scalar21 = workPart->Scalars()->CreateScalar(x0 + Porous2D::sheetLength, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar22;
        scalar22 = workPart->Scalars()->CreateScalar(y0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar23;
        scalar23 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint2 = workPart->Points()->CreatePoint(scalar21, scalar22, scalar23, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint2(setPoint2);
        //----Set setpoint3
        NXOpen::Scalar* scalar31;
        scalar31 = workPart->Scalars()->CreateScalar(x0 + Porous2D::sheetLength, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar32;
        scalar32 = workPart->Scalars()->CreateScalar(y0 + Porous2D::sheetWidth, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar33;
        scalar33 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint3 = workPart->Points()->CreatePoint(scalar31, scalar32, scalar33, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint3(setPoint3);
        //----Set setpoint4
        NXOpen::Scalar* scalar41;
        scalar41 = workPart->Scalars()->CreateScalar(x0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar42;
        scalar42 = workPart->Scalars()->CreateScalar(y0 + Porous2D::sheetWidth, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar43;
        scalar43 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint4 = workPart->Points()->CreatePoint(scalar41, scalar42, scalar43, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint4(setPoint4);
        //Create surface object
        NXOpen::NXObject* nXObjectSheet;
        nXObjectSheet = fourPointSurfaceBuilder1->Commit();
        //Pass to global parameters
        //----Get trim taget object
        Porous2D::SheetObject = nXObjectSheet;
        //----Get trim taget sheet bodies
        Porous2D::sheetBodys = dynamic_cast<NXOpen::Body*>(nXObjectSheet);
        Porous2D::sheetBodysCollector.push_back(Porous2D::sheetBodys);
        //Free memory
        fourPointSurfaceBuilder1->Destroy();
    }
}

//Generate particles curves
void Porous2D::GenParticleCurve(NXOpen::Part* workPart)
{
    //Create particle boundary curves
    //Create circle center point
    NXOpen::Point3d origin1(0.0, 0.0, 0.0);
    NXOpen::Vector3d normal1(0.0, 0.0, 1.0);
    NXOpen::Plane* plane1;
    plane1 = workPart->Planes()->CreatePlane(origin1, normal1, NXOpen::SmartObject::UpdateOptionWithinModeling);
    //Initialize generation method string
    std::string randomMethod = "Random";
    std::string squareMethod = "Square";
    std::string hexagonMethod = "Hexagon";
    std::string voronoiMethod = "Voronoi";
    NXOpen::NXString genMethod = Porous2D::enumGenMethod->ValueAsString();
    //Judge particle genaration method
    if ((std::string)genMethod.GetText() == randomMethod)
    {
        //Generate random particle curves
        GenRandom(workPart);
    }
    else if ((std::string)genMethod.GetText() == squareMethod)
    {
        //Generate square form particle porous
        GenSquare(workPart);
    }
    else if ((std::string)genMethod.GetText() == hexagonMethod)
    {
        //Generate hexagon form porous
        GenHexagon(workPart);
    }
    else if ((std::string)genMethod.GetText() == voronoiMethod)
    {
        //Generate Voronoi form porous
        GenVoronoi(workPart);
    }
    plane1->DestroyPlane();
}

//Generate random x or y in porous sheet zone
double Porous2D::GetRandomCoordinate(NXOpen::Part* workPart, std::string direction)
{
    NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
    double x0 = setPoint1->Coordinates().X;
    double y0 = setPoint1->Coordinates().Y;
    double z0 = setPoint1->Coordinates().Z;
    double particleSize = Porous2D::expressionParticleSize->Value();
    double xMax = x0 + Porous2D::expressionFaceLength->Value();
    double yMax = y0 + Porous2D::expressionFaceWidth->Value();
    //
    if (direction == "x")
    {
        return ((double)rand() / RAND_MAX) * (xMax - x0 - particleSize) + x0 + particleSize / 2.0;
    }
    else if (direction == "y")
    {
        return ((double)rand() / RAND_MAX) * (yMax - y0 - particleSize) + y0 + particleSize / 2.0;
    }
    else
    {
        uc1601("Error: Wrong direction in particle curve genaration!", 1);
    }
}

//Generate random x or y node number in porous sheet zone
int Porous2D::GetRandomNode(NXOpen::Part* workPart, std::string direction)
{

    if (direction == "x")
    {
        return ((rand() % (Porous2D::xNodeNumber - 1))+1);
    }
    else if (direction == "y")
    {
        return ((rand() % (Porous2D::yNodeNumber - 1))+1);
    }
    else
    {
        uc1601("Error: Wrong direction in particle curve genaration!", 1);
    }
}

//Generate random particle mesh
void Porous2D::MeshSheet(NXOpen::Part* workPart)
{
    Porous2D::xNodeNumber = floor(Porous2D::expressionFaceLength->Value() / Porous2D::expressionParticleSize->Value());
    Porous2D::yNodeNumber = floor(Porous2D::expressionFaceWidth->Value() / Porous2D::expressionParticleSize->Value());
    double xNodeLength = Porous2D::expressionFaceLength->Value() / (double)xNodeNumber;
    double yNodeLength = Porous2D::expressionFaceWidth->Value() / (double)yNodeNumber;
    for (int i = 0; i <= xNodeNumber; i++)
    {
        for (int j = 0; j <= yNodeNumber; j++)
        {
            double x0 = Porous2D::pointSheetStart->Point().X;
            double y0 = Porous2D::pointSheetStart->Point().Y;
            double z0 = Porous2D::pointSheetStart->Point().Z;
            Porous2D::nodeMeshX.push_back((double)(i * xNodeLength) + x0);
            Porous2D::nodeMeshY.push_back((double)(j * yNodeLength) + y0);
            //char msg[256];
            //sprintf(msg, "i:%d,j:%d;nPick:%d;*xNode:%d;yNode:%d;*xNodeX:%f;yNodeY:%f;*x0:%f;y0:%f;*xLength:%f;yLength:%f",i,j,nPick,xNode,yNode,xNodeX,yNodeY,x0,y0,xNodeLength,yNodeLength);
            //uc1601(msg, 1);
        }
    }
}

//Trim sheet to get porous 
void Porous2D::TrimPorousSheet(NXOpen::Part* workPart)
{
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t剪切片体：\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t剪切片体：" << endl;
    }
    //Trim sheet to get porous
    //Initialize parameters
    int currentParticleNum = 0;
    NXOpen::NXObject* nullNXOpen_NXObject(NULL);
    //Initialize TrimSheetBuilder
    NXOpen::Features::Feature* nullNXOpen_Features_Feature(NULL);
    NXOpen::Features::TrimSheetBuilder* trimSheetBuilder1;
    trimSheetBuilder1 = workPart->Features()->CreateTrimsheetBuilder(nullNXOpen_Features_Feature);
    trimSheetBuilder1->SetTolerance(0.001);
    trimSheetBuilder1->SetExtendBoundaryObject(true);
    //Set trim taget object
    bool added1;
    added1 = trimSheetBuilder1->TargetBodies()->Add(Porous2D::sheetBodys);
    //Set maintain region referrence point
    NXOpen::Point* point1;
    point1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
    NXOpen::RegionPoint* regionPoint1;
    regionPoint1 = workPart->CreateRegionPoint(point1, Porous2D::sheetBodys);
    trimSheetBuilder1->Regions()->Append(regionPoint1);
    NXOpen::Direction* nullNXOpen_Direction(NULL);
    trimSheetBuilder1->ProjectionDirection()->SetProjectVector(nullNXOpen_Direction);
    //Set trim section
    NXOpen::Section* section1;
    section1 = workPart->Sections()->CreateSection(0.00095, 0.001, 0.050000000000000003);
    section1->SetAllowedEntityTypes(NXOpen::Section::AllowTypesOnlyCurves);
    //Set section as TrimSheetBuilder boundary
    bool added2;
    added2 = trimSheetBuilder1->BoundaryObjects()->Add(section1);
    //----Set curve collector vector 
    std::vector<NXOpen::IBaseCurve*> curves1(Porous2D::particleNumber);
    std::vector<NXOpen::Arc*> arcSelected(Porous2D::particleNumber);
    std::vector<NXOpen::Spline*> splineSelected(Porous2D::particleNumber);
    char tempString[256];
    //Set loop
    while (currentParticleNum < Porous2D::particleNumber)
    {
        if ((std::string)(enumGenMethod->ValueAsString().GetText()) == "Voronoi")
        {
            splineSelected[currentParticleNum] = dynamic_cast<NXOpen::Spline*>(splineFeatureCollector[currentParticleNum]->FindObject("CURVE 1"));
            curves1[currentParticleNum] = splineSelected[currentParticleNum];
            //----Print process to info window
            //if (Porous2D::togglePrintInfo->Value() == true)
            //{
            //    std::sprintf(tempString, "->\t%d:\tcurveNum:%I64u\tcurveCap:%I64u\n",currentParticleNum,curves1.size(),curves1.capacity());
            //    UF_UI_write_listing_window(tempString);
            //}
        }
        else if ((std::string)(enumParticleShape->ValueAsString().GetText()) == "Circle")
        {
            arcSelected[currentParticleNum] = dynamic_cast<NXOpen::Arc*>(Porous2D::arcFeatureCollector[currentParticleNum]->FindObject("CURVE 1"));
            curves1[currentParticleNum] = arcSelected[currentParticleNum];
            //----Print process to info window
            //if (Porous2D::togglePrintInfo->Value() == true)
            //{
            //    std::sprintf(tempString, "->\t%d:\tcurveNum:%I64u\tcurveCap:%I64u\n",currentParticleNum,curves1.size(),curves1.capacity());
            //    UF_UI_write_listing_window(tempString);
            //}
        }
        //Update particle number
        currentParticleNum++;
    }
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        std::sprintf(tempString, "->\tcurveNum:%I64u\n", curves1.size());
        UF_UI_write_listing_window(tempString);
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\tcurveNum:" << curves1.size() << endl;
    }
    NXOpen::CurveDumbRule* curveDumbRule1;
    curveDumbRule1 = workPart->ScRuleFactory()->CreateRuleBaseCurveDumb(curves1);
    section1->AllowSelfIntersection(true);
    //----Set SelectionIntentRule
    std::vector<NXOpen::SelectionIntentRule*> rules1(1);
    rules1[0] = curveDumbRule1;
    //----Add rules to section
    NXOpen::Point3d helpPointOrigin(0.0, 0.0, 0.0);
    section1->AddToSection(rules1, nullNXOpen_NXObject, nullNXOpen_NXObject, nullNXOpen_NXObject, helpPointOrigin, NXOpen::Section::ModeCreate, false);
    trimSheetBuilder1->ProjectionDirection()->SetProjectVector(nullNXOpen_Direction);
    //Trim sheet
    NXOpen::NXObject* nXObjectTrimPorousSheet;
    nXObjectTrimPorousSheet = trimSheetBuilder1->Commit();
    //Pass to global parameters
    //----Get porous2D taget object
    Porous2D::porousSheetObject = nXObjectTrimPorousSheet;
    //----Get trim taget sheet bodies
    Porous2D::porousBodys2D = dynamic_cast<NXOpen::Body*>(nXObjectTrimPorousSheet);
    Porous2D::porousBodys2DCollector.push_back(Porous2D::porousBodys2D);
    //Free memory
    trimSheetBuilder1->Destroy();
}

//Generate 3D porous medium
void Porous2D::GenPorous3D(NXOpen::Part* workPart)
{
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        char tempString[256];
        UF_UI_write_listing_window("->\t生成3D介质：\n");
        std::sprintf(tempString, "->\t拉伸长度:%f (mm)\n", Porous2D::expressionSheetLen->Value());
        UF_UI_write_listing_window(tempString);
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t生成3D介质：" << endl;
        Porous2D::outf << "->\t拉伸长度:" << Porous2D::expressionSheetLen->Value() << " (mm)" << endl;
    }
    //Create thickenBuilder to sheet
    NXOpen::Features::Feature *nullNXOpen_Features_Feature(NULL);
    NXOpen::Features::ThickenBuilder *thickenBuilder1;
    thickenBuilder1 = workPart->Features()->CreateThickenBuilder(nullNXOpen_Features_Feature);
    thickenBuilder1->SetTolerance(0.001);
    thickenBuilder1->RegionToPierce()->SetDistanceTolerance(0.001);
    thickenBuilder1->RegionToPierce()->SetChainingTolerance(0.00095);
    //----Find Journalldentifier of sheet body
    NXOpen::NXString sheetID = Porous2D::SheetObject->JournalIdentifier();
    NXOpen::Body *body1(dynamic_cast<NXOpen::Body *>(workPart->Bodies()->FindObject(sheetID)));
    NXOpen::FaceBodyRule *faceBodyRule1;
    faceBodyRule1 = workPart->ScRuleFactory()->CreateRuleFaceBody(body1);
    std::vector<NXOpen::SelectionIntentRule *> rules1(1);
    rules1[0] = faceBodyRule1;
    thickenBuilder1->FaceCollector()->ReplaceRules(rules1, false);
    //----Set distance to thicken
    thickenBuilder1->FirstOffset()->SetValue(Porous2D::expressionSheetLen->Value());
    NXOpen::NXObject *nXObjectThickenSheet;
    nXObjectThickenSheet = thickenBuilder1->Commit();
    thickenBuilder1->Destroy();
}
//------------------------------------------------------------------------------

//Generate random form porous
void Porous2D::GenRandom(NXOpen::Part* workPart)
{
    MeshSheet(workPart);
    //Generate random seed
    std::srand((unsigned)std::time(0));
    bool randomPR = Porous2D::toggleUsePorousRatio->Value();
    if (randomPR)
    {
        double ratio = Porous2D::doublePorousRatio->Value();
        double length = Porous2D::expressionFaceLength->Value();
        double width = Porous2D::expressionFaceWidth->Value();
        double diameter = Porous2D::expressionParticleSize->Value();
        Porous2D::particleNumber = floor((1.0 - ratio) * length * width / (PI * diameter * diameter / 4.0));
    }
    else
    {
        Porous2D::particleNumber = Porous2D::integerParticleNumber->Value();
    }
    //Judge particle shape
    if ((std::string)(Porous2D::enumParticleShape->ValueAsString()).GetText() == "Circle")
    {
        //Create circle center point
        //Generate circle particle curves
        for (int i = 0; i < Porous2D::particleNumber; i++)
        {
            //Initialize AssociativeArcBuiler
            NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
            NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
            associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
            //Get random particles' center points 
            //----Get sheet start point's coordinate
            NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
            double x0 = setPoint1->Coordinates().X;
            double y0 = setPoint1->Coordinates().Y;
            double z0 = setPoint1->Coordinates().Z;
            NXOpen::Point* circleCorePoint1;
            double xPick, yPick, zPick;
            if (Porous2D::toggleMeshRandom->Value() == false)
            {
                //----Create random circle center points
                xPick = GetRandomCoordinate(workPart, "x");
                yPick = GetRandomCoordinate(workPart, "y");
                zPick = z0;
            }
            else
            {
                int nodeI, nodeJ, nodePick;
                nodeI = GetRandomNode(workPart, "x");
                nodeJ = GetRandomNode(workPart, "y");
                nodePick = nodeI * (Porous2D::yNodeNumber + 1)+ nodeJ + 1;
                xPick = Porous2D::nodeMeshX[(int)(nodePick-1)];
                yPick = Porous2D::nodeMeshY[(int)(nodePick-1)];
                zPick = z0;
            }
            NXOpen::Scalar* scalarX1(NULL);
            scalarX1 = workPart->Scalars()->CreateScalar(xPick, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
            NXOpen::Scalar* scalarY1(NULL);
            scalarY1 = workPart->Scalars()->CreateScalar(yPick, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
            NXOpen::Scalar* scalarZ1(NULL);
            scalarZ1 = workPart->Scalars()->CreateScalar(zPick, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
            circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
            Porous2D::centerPointCollector.push_back(circleCorePoint1);
            //Set AssociativeArcBuilder parameters
            //----Create helpPoints for trim section
            Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + Porous2D::expressionParticleSize->Value() / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
            Porous2D::helpPointCollector.push_back(helpPoint);
            //----Set circle curves' genaration plane
            NXOpen::Vector3d Vector1;
            Vector1 = { 0.0, 0.0, 1.0 };
            //----Open switch to set plane normal direction
            NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
            planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
            associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
            //----Set AssociativeArcBuilder required parameters
            associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
            associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
            associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
            associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
            associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionParticleSize->Value());
            associativeArcBuilder1->Limits()->SetFullCircle(true);
            //Create circle particle curves
            NXOpen::NXObject* nXObjectCircle;
            nXObjectCircle = associativeArcBuilder1->Commit();
            //Pass to global parameters
            //----Get particle curves' objects
            Porous2D::particleObject.push_back(nXObjectCircle);
            //----Get particle curves' features
            Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
            Porous2D::arcFeatureCollector.push_back(arcFeature);
            //Free memory
            associativeArcBuilder1->Destroy();
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
    {

    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
    {

    }
}

//Generate square form porous
void Porous2D::GenSquare(NXOpen::Part* workPart)
{
    //Judge particle shape
    if ((std::string)(Porous2D::enumParticleShape->ValueAsString()).GetText() == "Circle")
    {
        //----Get sheet start point's coordinate
        NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
        double x0 = setPoint1->Coordinates().X;
        double y0 = setPoint1->Coordinates().Y;
        double z0 = setPoint1->Coordinates().Z;
        //----Get sheet center point's coordinate
        double xSheetCenter = setPoint1->Coordinates().X + Porous2D::expressionFaceLength->Value() / 2.0;
        double ySheetCenter = setPoint1->Coordinates().Y + Porous2D::expressionFaceWidth->Value() / 2.0;
        double zSheetCenter = setPoint1->Coordinates().Z;
        //----Get porous zone boundary start point coordinary
        NXOpen::Point* pointPorousZoneStart;
        double xZoneStart, yZoneStart, zZoneStart;
        double zoneLength, zoneWidth;
        if (Porous2D::toggleOutFluid->Value() == false)
        {
            double xZoneStart = xSheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
            double yZoneStart = ySheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
            double zZoneStart = zSheetCenter;
            zoneLength = min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
            zoneWidth = zoneLength;
        }
        else
        {
            double xZoneStart = x0;
            double yZoneStart = y0;
            double zZoneStart = z0;
            zoneLength = max(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
            zoneWidth = min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
        }
        //----Define local parameters
        double ratio = Porous2D::doublePorousRatio->Value();
        double diameter = Porous2D::expressionParticleSize->Value();
        //----Compute colum of particle square
        int numSquare = floor(sqrt(zoneLength * zoneWidth * (1.0 - ratio) * 4.0 / PI / (diameter * diameter)));
        double particleLength = floor(sqrt(zoneLength * zoneWidth / numSquare));
        int rowSquare = floor(zoneWidth / particleLength);
        int columeSquare = floor(numSquare / rowSquare);
        Porous2D::particleNumber = rowSquare * columeSquare;
        double rowGap = zoneWidth / (double)rowSquare - diameter;
        double columeGap = zoneLength / (double)columeSquare - diameter;
        double rowBoderGap = rowGap / 2.0;
        double columeBoderGap = columeGap / 2.0;
        //----Compute start point coordination
        double xStartPoint = xZoneStart + columeBoderGap + diameter / 2.0;
        double yStartPoint = yZoneStart + rowBoderGap + diameter / 2.0;
        double zStartPoint = zZoneStart;
        //Generate circle particle curves
        for (int i = 0; i < rowSquare; i++)
        {
            for (int j = 0; j < columeSquare; j++)
            {
                //Initialize AssociativeArcBuiler
                NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                //Get particles' center points 
                //----Create  circle center points
                double x = xStartPoint + (diameter + columeGap) * j;
                double y = yStartPoint + (diameter + rowGap) * i;
                NXOpen::Scalar* scalarX1(NULL);
                scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Scalar* scalarY1(NULL);
                scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Scalar* scalarZ1(NULL);
                scalarZ1 = workPart->Scalars()->CreateScalar(zStartPoint, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Point* circleCorePoint1;
                circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                Porous2D::centerPointCollector.push_back(circleCorePoint1);
                //Set AssociativeArcBuilder parameters
                //----Create helpPoints for trim section
                Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                Porous2D::helpPointCollector.push_back(helpPoint);
                //----Set circle curves' genaration plane
                NXOpen::Vector3d Vector1;
                Vector1 = { 0.0, 0.0, 1.0 };
                //----Open switch to set plane normal direction
                NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                //----Set AssociativeArcBuilder required parameters
                associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionParticleSize->Value());
                associativeArcBuilder1->Limits()->SetFullCircle(true);
                //Create circle particle curves
                NXOpen::NXObject* nXObjectCircle;
                nXObjectCircle = associativeArcBuilder1->Commit();
                //Pass to global parameters
                //----Get particle curves' objects
                Porous2D::particleObject.push_back(nXObjectCircle);
                //----Get particle curves' features
                Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                Porous2D::arcFeatureCollector.push_back(arcFeature);
                //Free memory
                associativeArcBuilder1->Destroy();
            }
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
    {

    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
    {

    }
}

//Generate hexagon form porous
void Porous2D::GenHexagon(NXOpen::Part* workPart)
{
    //Judge particle shape
    if ((std::string)(Porous2D::enumParticleShape->ValueAsString()).GetText() == "Circle")
    {
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t生成颗粒：六边形阵列 | 圆形颗粒\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t生成颗粒：六边形阵列 | 圆形颗粒" << endl;
        }
        //Judge generation method
        if (Porous2D::togglePaper->Value() == true)
        {
            //----Print process to info window
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t------------------纸幅专用生成方式------------------\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t------------------纸幅专用生成方式------------------" << endl;
            }
            //----Get sheet start point's coordinate
            NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
            double x0 = setPoint1->Coordinates().X;
            double y0 = setPoint1->Coordinates().Y;
            double z0 = setPoint1->Coordinates().Z;
            //----Get sheet height
            if (Porous2D::sheetWidth == 0)
            {
                Porous2D::sheetWidth = Porous2D::expressionBasisWeight->Value() /1000.0 * Porous2D::expressionDryContentFinal->Value() / 100.0\
                    / (1.0 - Porous2D::doublePorousRatio->Value()) * (1.0 / 1.5e3 + (1.0 - Porous2D::expressionDryContentNow->Value() / 100.0) \
                        / (Porous2D::expressionDryContentNow->Value() / 100.0) / 1e3) * 1000.0;
                Porous2D::sheetLength = Porous2D::sheetWidth * Porous2D::expressionLenWidRatio->Value();
            }
            //----Get sheet center point's coordinate
            double xSheetCenter = setPoint1->Coordinates().X + Porous2D::sheetLength / 2.0;
            double ySheetCenter = setPoint1->Coordinates().Y + Porous2D::sheetWidth / 2.0;
            double zSheetCenter = setPoint1->Coordinates().Z;
            //----Get porous zone boundary start point coordinary
            NXOpen::Point* pointPorousZoneStart;
            double xZoneStart = xSheetCenter - Porous2D::sheetLength / 2.0;
            double yZoneStart = ySheetCenter - Porous2D::sheetWidth / 2.0;
            double zZoneStart = zSheetCenter;
            double zoneLength = Porous2D::sheetLength;
            double zoneWidth = Porous2D::sheetWidth;
            //----Define local parameters
            double ratio = Porous2D::doublePorousRatio->Value();
            double diameter = Porous2D::expressionCelDiameter->Value();
            //----Compute colum of particle hexagon
            double gap = sqrt(PI / 2.0 / sqrt(3.0) / (1.0 -ratio)) * diameter;
            int rowHexagon = floor(Porous2D::sheetWidth / (sqrt(3.0) / 2.0 * gap));
            int columHexagon = floor(zoneLength / gap);
//            Porous2D::particleNumber = floor(zoneLength * Porous2D::sheetWidth * (1.0 - ratio) * 4.0 / PI / (diameter * diameter));
            Porous2D::particleNumber = rowHexagon * columHexagon;
            double rowBoderGap = (zoneLength - gap * (columHexagon + 0.5)) / 2.0;
            double colBoderGap = (Porous2D::sheetWidth - rowHexagon * gap * sqrt(3.0) / 2.0) / 2.0;
            double realRatio = (1.0 - Porous2D::particleNumber * PI * diameter * diameter / 4.0 / (zoneLength * zoneWidth)) * 100.0;
            //----Compute start point coordination
            double xStartPoint = xZoneStart + rowBoderGap + gap / 2.0;
            double yStartPoint = yZoneStart + colBoderGap + gap / 2.0;
            double zStartPoint = zZoneStart;
            //----Print process to info window
            char tempString[256];
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t纸幅基本信息：\n");
                std::sprintf(tempString, "->\t纸幅基重:%f (g/m2)\n", Porous2D::expressionBasisWeight->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t成纸干度:%f (%)\n", Porous2D::expressionDryContentFinal->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t当前干度:%f (%)\n", Porous2D::expressionDryContentNow->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纸幅厚度:%f (mm)\n", Porous2D::sheetWidth);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纤维直径:%f (mm)\n", Porous2D::expressionCelDiameter->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纤维长度:%f (mm)\n", Porous2D::expressionCelLength->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纤维长度密度:%f (g/m)\n", Porous2D::expressionLenDensity->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t行数:%d\t纤维行间距:%f (mm)\n", rowHexagon, sqrt(3.0)/2.0*gap);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t列数:%d\t纤维列间距:%f (mm)\n", columHexagon, gap);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纤维数量:%d \n", Porous2D::particleNumber);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t设计孔隙率:%f (\%)\n", ratio * 100.0);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t实际孔隙率:%f (\%)\n", realRatio);
                UF_UI_write_listing_window(tempString);
                UF_UI_write_listing_window("->\t纤维圆心坐标：\n");
                UF_UI_write_listing_window("->\t[row,colum]\tx\ty\tz\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t纸幅基本信息：\n" << "->\t纸幅基重:" << Porous2D::expressionDryContentFinal->Value() << " (%)" << endl;
                Porous2D::outf << "->\t当前干度:" << Porous2D::expressionDryContentNow->Value() << " (%)" << endl;
                Porous2D::outf << "->\t纸幅厚度:" << Porous2D::sheetWidth << " (mm)" << endl;
                Porous2D::outf << "->\t纤维直径:" << Porous2D::expressionCelDiameter->Value() << " (mm)" << endl;
                Porous2D::outf << "->\t纤维长度:" << Porous2D::expressionCelLength->Value() << " (mm)" << endl;
                Porous2D::outf << "->\t纤维长度密度:" << Porous2D::expressionLenDensity->Value() << " (g/m)" << endl;
                Porous2D::outf << "->\t行数:" << rowHexagon << "\t纤维行间距: " << sqrt(3.0)/2.0*gap << " (mm)" << endl;
                Porous2D::outf << "->\t列数:" << columHexagon << "\t纤维行间距: " << gap << " (mm)" << endl;
                Porous2D::outf << "->\t纤维数量:" << Porous2D::particleNumber << endl;
                Porous2D::outf << "->\t设计孔隙率:" << ratio * 100.0 << " (%)" << endl;
                Porous2D::outf << "->\t实际孔隙率:" << realRatio << " (%)" << endl;
                Porous2D::outf << "->\t纤维圆心坐标:" << endl;
                Porous2D::outf << "->\t[row,colum]\tx\ty\tz" << endl;
            }
            for (int i = 0; i < rowHexagon; i++)
            {
                for (int j = 0; j < columHexagon; j++)
                {
                    //Initialize AssociativeArcBuiler
                    NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                    NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                    associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                    //Get particles' center points 
                    //----Create  circle center points
                    double x = xStartPoint + (gap / 2.0) * abs(sin((double)i / 2.0 * PI)) + gap * j;
                    double y = yStartPoint + sqrt(3.0) * gap / 2.0 * i;
                    double z = zStartPoint;
                    NXOpen::Scalar* scalarX1(NULL);
                    scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarY1(NULL);
                    scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarZ1(NULL);
                    scalarZ1 = workPart->Scalars()->CreateScalar(z, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Point* circleCorePoint1;
                    circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    Porous2D::centerPointCollector.push_back(circleCorePoint1);
                    //----Print center points coordination of cellulose
                    if (Porous2D::togglePrintInfo->Value() == true)
                    {
                        std::sprintf(tempString, "->\t[%d,%d]\t%f\t%f\t%f\n",i+1,j+1,x,y,z);
                        UF_UI_write_listing_window(tempString);
                    }
                    //----Print process to log file
                    if (Porous2D::toggleWriteFile->Value() == true)
                    {
                        Porous2D::outf << "->\t[" << i + 1 << "," << j + 1 << "]\t" << x << ",\t" << y << ",\t" << z << endl;
                    }
                    //Set AssociativeArcBuilder parameters
                    //----Create helpPoints for trim section
                    Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                    Porous2D::helpPointCollector.push_back(helpPoint);
                    //----Set circle curves' genaration plane
                    NXOpen::Vector3d Vector1;
                    Vector1 = { 0.0, 0.0, 1.0 };
                    //----Open switch to set plane normal direction
                    NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                    planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                    associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                    //----Set AssociativeArcBuilder required parameters
                    associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                    associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                    associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                    associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                    associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionCelDiameter->Value());
                    associativeArcBuilder1->Limits()->SetFullCircle(true);
                    //Create circle particle curves
                    NXOpen::NXObject* nXObjectCircle;
                    nXObjectCircle = associativeArcBuilder1->Commit();
                    //Pass to global parameters
                    //----Get particle curves' objects
                    Porous2D::particleObject.push_back(nXObjectCircle);
                    //----Get particle curves' features
                    Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                    Porous2D::arcFeatureCollector.push_back(arcFeature);
                    //Free memory
                    associativeArcBuilder1->Destroy();
                }
            }
            //Print length of arcFeatureCollector and particleObject
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                int arcFeatureNum = Porous2D::arcFeatureCollector.size();
                int parObjectNum = Porous2D::particleObject.size();
                int arcFeatureMax = Porous2D::arcFeatureCollector.max_size();
                int parObjectMax = Porous2D::particleObject.max_size();
                int arcFeatureCap = Porous2D::arcFeatureCollector.capacity();
                int parObjectCap = Porous2D::particleObject.capacity();
                std::sprintf(tempString, "->\tarcFeatureNum:\t%d\tparticleObjectNum:\t%d\n",arcFeatureNum,parObjectNum);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\tarcFeatureMax:\t%d\tparticleObjectMax:\t%d\n",arcFeatureMax,parObjectMax);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\tarcFeatureCap:\t%d\tparticleObjectCap:\t%d\n",arcFeatureCap,parObjectCap);
                UF_UI_write_listing_window(tempString);
            }
        }
        else
        {
            //----Print process to info window
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t------------------普通介质生成方式------------------\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t------------------普通介质生成方式------------------" << endl;
            }
            //----Get sheet start point's coordinate
            NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
            double x0 = setPoint1->Coordinates().X;
            double y0 = setPoint1->Coordinates().Y;
            double z0 = setPoint1->Coordinates().Z;
            //----Get sheet center point's coordinate
            double xSheetCenter = setPoint1->Coordinates().X + Porous2D::expressionFaceLength->Value() / 2.0;
            double ySheetCenter = setPoint1->Coordinates().Y + Porous2D::expressionFaceWidth->Value() / 2.0;
            double zSheetCenter = setPoint1->Coordinates().Z;
            //----Get porous zone boundary start point coordinary
            NXOpen::Point* pointPorousZoneStart;
            double xZoneStart = xSheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
            double yZoneStart = ySheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
            double zZoneStart = zSheetCenter;
            double zoneLength = min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
            //----Define local parameters
            double ratio = Porous2D::doublePorousRatio->Value();
            double diameter = Porous2D::expressionParticleSize->Value();
            //----Compute colum of particle hexagon
            int rowHexagon = floor(sqrt(zoneLength * zoneLength * (1.0 - ratio) * 4.0 / PI / (diameter * diameter)));
            Porous2D::particleNumber = rowHexagon * rowHexagon;
            double realPorosity = (1.0 - Porous2D::particleNumber * PI * diameter * diameter / 4.0 / (zoneLength * zoneLength)) * 100.0;
            double gap = 2.0 * zoneLength / (2.0 * (double)rowHexagon + 1.0) - diameter;
            double boderGap = gap / 2.0;
            double extraBoderGap = (diameter + gap) * ((2.0 - sqrt(3.0)) * rowHexagon / 2.0 + (sqrt(3.0) - 1.0) / 2.0) / 2.0;
            //----Print process to info window
            char tempString[256];
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t介质基本信息：\n");
                std::sprintf(tempString, "->\t介质长度:%f (mm)\n", Porous2D::expressionFaceLength->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t介质宽度:%f (mm)\n", Porous2D::expressionFaceWidth->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t设计孔隙率:%f (\%)\n", ratio * 100.0);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t实际孔隙率:%f (\%)\n", realPorosity);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t行数:%d\t纤维行间距:%f (mm)\n", rowHexagon, sqrt(3.0)/2.0*gap);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t列数:%d\t纤维列间距:%f (mm)\n", rowHexagon, gap);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纤维数量:%d \n", Porous2D::particleNumber);
                UF_UI_write_listing_window(tempString);
                UF_UI_write_listing_window("->\t纤维圆心坐标：\n");
                UF_UI_write_listing_window("->\t[row,colum]\tx\ty\tz\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t介质基本信息：\n" << "->\t介质长度:" << Porous2D::expressionFaceLength->Value() << " (mm)" << endl;
                Porous2D::outf << "->\t介质宽度:" << Porous2D::expressionFaceWidth->Value() << " (mm)" << endl;
                Porous2D::outf << "->\t设计孔隙率:" << ratio * 100.0 << " (%)" << endl;
                Porous2D::outf << "->\t实际孔隙率:" << realPorosity << " (%)" << endl;
                Porous2D::outf << "->\t行数:" << rowHexagon << "\t纤维行间距: " << sqrt(3.0)/2.0*gap << " (mm)" << endl;
                Porous2D::outf << "->\t列数:" << rowHexagon << "\t纤维行间距: " << gap << " (mm)" << endl;
                Porous2D::outf << "->\t纤维数量:" << Porous2D::particleNumber << endl;
                Porous2D::outf << "->\t纤维圆心坐标:" << endl;
                Porous2D::outf << "->\t[row,colum]\tx\ty\tz" << endl;
            }
            //Generate circle particle curves
            //Judge hexagon direction
            if (Porous2D::expressionFaceLength->Value() <= Porous2D::expressionFaceWidth->Value())
            {
                //Compute start point coordination
                double xStartPoint = xZoneStart + boderGap + diameter / 2.0;
                double yStartPoint = yZoneStart + boderGap + extraBoderGap + diameter / 2.0;
                double zStartPoint = zZoneStart;
                for (int i = 0; i < rowHexagon; i++)                                                                                                                                                                                                            
                {
                    for (int j = 0; j < rowHexagon; j++)
                    {
                        //Initialize AssociativeArcBuiler
                        NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                        NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                        associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                        //Get particles' center points 
                        //----Create  circle center points
                        double x = xStartPoint + ((diameter + gap) / 2.0) * abs(sin((double)i / 2.0 * PI)) + (diameter + gap) * j;
                        double y = yStartPoint + sqrt(3.0) * (diameter + gap) / 2.0 * i;
                        double z = zStartPoint;
                        NXOpen::Scalar* scalarX1(NULL);
                        scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                        NXOpen::Scalar* scalarY1(NULL);
                        scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                        NXOpen::Scalar* scalarZ1(NULL);
                        scalarZ1 = workPart->Scalars()->CreateScalar(zStartPoint, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                        NXOpen::Point* circleCorePoint1;
                        circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                        Porous2D::centerPointCollector.push_back(circleCorePoint1);
                        //Set AssociativeArcBuilder parameters
                        //----Create helpPoints for trim section
                        Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                        Porous2D::helpPointCollector.push_back(helpPoint);
                        //----Print center points coordination of cellulose
                        if (Porous2D::togglePrintInfo->Value() == true)
                        {
                            std::sprintf(tempString, "->\t[%d,%d]\t%f\t%f\t%f\n",i+1,j+1,x,y,z);
                            UF_UI_write_listing_window(tempString);
                        }
                        //----Print process to log file
                        if (Porous2D::toggleWriteFile->Value() == true)
                        {
                            Porous2D::outf << "->\t[" << i + 1 << "," << j + 1 << "]\t" << x << ",\t" << y << ",\t" << z << endl;
                        }
                        //----Set circle curves' genaration plane
                        NXOpen::Vector3d Vector1;
                        Vector1 = { 0.0, 0.0, 1.0 };
                        //----Open switch to set plane normal direction
                        NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                        planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                        associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                        //----Set AssociativeArcBuilder required parameters
                        associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                        associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                        associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                        associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                        associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionParticleSize->Value());
                        associativeArcBuilder1->Limits()->SetFullCircle(true);
                        //Create circle particle curves
                        NXOpen::NXObject* nXObjectCircle;
                        nXObjectCircle = associativeArcBuilder1->Commit();
                        //Pass to global parameters
                        //----Get particle curves' objects
                        Porous2D::particleObject.push_back(nXObjectCircle);
                        //----Get particle curves' features
                        Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                        Porous2D::arcFeatureCollector.push_back(arcFeature);
                        //Free memory
                        associativeArcBuilder1->Destroy();
                    }
                }
                //Print length of arcFeatureCollector and particleObject
                if (Porous2D::togglePrintInfo->Value() == true)
                {
                    int arcFeatureNum = Porous2D::arcFeatureCollector.size();
                    int parObjectNum = Porous2D::particleObject.size();
                    int arcFeatureMax = Porous2D::arcFeatureCollector.max_size();
                    int parObjectMax = Porous2D::particleObject.max_size();
                    std::sprintf(tempString, "->\tarcFeatureNum:\t%d\tparticleObjectNum:\t%d\n",arcFeatureNum,parObjectNum);
                    UF_UI_write_listing_window(tempString);
                    std::sprintf(tempString, "->\tarcFeatureCapacity:\t%d\tparticleObjectCapacity:\t%d\n",arcFeatureMax,parObjectMax);
                    UF_UI_write_listing_window(tempString);
                }
            }
            else
            {
                //Compute start point coordination
                double xStartPoint = xZoneStart + boderGap + extraBoderGap + diameter / 2.0;
                double yStartPoint = yZoneStart + boderGap + diameter / 2.0;
                double zStartPoint = zZoneStart;
                for (int i = 0; i < rowHexagon; i++)                                                                                                                                                                                                            
                {
                    for (int j = 0; j < rowHexagon; j++)
                    {
                        //Initialize AssociativeArcBuiler
                        NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                        NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                        associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                        //Get particles' center points 
                        //----Create  circle center points
                        double x = xStartPoint + sqrt(3.0) * (diameter + gap) / 2.0 * i;
                        double y = yStartPoint + ((diameter + gap) / 2.0) * abs(sin((double)i / 2.0 * PI)) + (diameter + gap) * j;
                        double z = zStartPoint;
                        NXOpen::Scalar* scalarX1(NULL);
                        scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                        NXOpen::Scalar* scalarY1(NULL);
                        scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                        NXOpen::Scalar* scalarZ1(NULL);
                        scalarZ1 = workPart->Scalars()->CreateScalar(zStartPoint, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                        NXOpen::Point* circleCorePoint1;
                        circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                        Porous2D::centerPointCollector.push_back(circleCorePoint1);
                        //Set AssociativeArcBuilder parameters
                        //----Create helpPoints for trim section
                        helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                        helpPointCollector.push_back(helpPoint);
                        //----Print center points coordination of cellulose
                        if (Porous2D::togglePrintInfo->Value() == true)
                        {
                            std::sprintf(tempString, "->\t[%d,%d]\t%f\t%f\t%f\n",i+1,j+1,x,y,z);
                            UF_UI_write_listing_window(tempString);
                        }
                        //----Print process to log file
                        if (Porous2D::toggleWriteFile->Value() == true)
                        {
                            Porous2D::outf << "->\t[" << i + 1 << "," << j + 1 << "]\t" << x << ",\t" << y << ",\t" << z << endl;
                        }
                        //----Set circle curves' genaration plane
                        NXOpen::Vector3d Vector1;
                        Vector1 = { 0.0, 0.0, 1.0 };
                        //----Open switch to set plane normal direction
                        NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                        planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                        associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                        //----Set AssociativeArcBuilder required parameters
                        associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                        associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                        associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                        associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                        associativeArcBuilder1->Diameter()->SetValue(expressionParticleSize->Value());
                        associativeArcBuilder1->Limits()->SetFullCircle(true);
                        //Create circle particle curves
                        NXOpen::NXObject* nXObjectCircle;
                        nXObjectCircle = associativeArcBuilder1->Commit();
                        //Pass to global parameters
                        //----Get particle curves' objects
                        particleObject.push_back(nXObjectCircle);
                        //----Get particle curves' features
                        arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                        arcFeatureCollector.push_back(arcFeature);
                        //Free memory
                        associativeArcBuilder1->Destroy();
                    }
                }
                //Print length of arcFeatureCollector and particleObject
                if (Porous2D::togglePrintInfo->Value() == true)
                {
                    int arcFeatureNum = Porous2D::arcFeatureCollector.size();
                    int parObjectNum = Porous2D::particleObject.size();
                    int arcFeatureMax = Porous2D::arcFeatureCollector.max_size();
                    int parObjectMax = Porous2D::particleObject.max_size();
                    std::sprintf(tempString, "->\tarcFeatureNum:\t%d\tparticleObjectNum:\t%d\n",arcFeatureNum,parObjectNum);
                    UF_UI_write_listing_window(tempString);
                    std::sprintf(tempString, "->\tarcFeatureCapacity:\t%d\tparticleObjectCapacity:\t%d\n",arcFeatureMax,parObjectMax);
                    UF_UI_write_listing_window(tempString);
                }
            }
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
    {

    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
    {

    }
}

bool sitesOrdered(const Point2& s1, const Point2& s2)
{
    if (s1.y < s2.y)
    {
        return true;
    }
    else if (s1.y == s2.y && s1.x < s2.x)
    {
        return true;
    }
    else
    {
        return false;
    }
}

//class compare 
//{
//public:
//    double vertxMinX;
//    double vertxMinY;
//    std::vector<Point2> sortVtx1;
//    void orderVertxPoints(std::vector<Point2>& vertxPoints);
//    bool vertxOrdered(const Point2& s1, const Point2& s2);
//};

static double vertxMinX;
static double vertxMinY;

static bool vertxOrdered(const Point2 & s1, const Point2 & s2)
{
    double dx1 = s1.x - vertxMinX;
    double dy1 = s1.y - vertxMinY;
    double dx2 = s2.x - vertxMinX;
    double dy2 = s2.y - vertxMinY;
    double sModule1 = sqrt(dx1 * dx1 + dy1 * dy1);
    double sModule2 = sqrt(dx2 * dx2 + dy2 * dy2);
    double thelta1 = acos(dx1 / sModule1);
    double thelta2 = acos(dx2 / sModule2);
    if (thelta1 < thelta2)
    {
        return true;
    }
    else
    {
        return false;
    }
}

void orderVertxPoints(std::vector<Point2>&vertxPoints,std::vector<Point2>&sortedVertx)
{
    // Delete dipulate elements
//    static double vertxMinX;
//    static double vertxMinY;

    std::sort(vertxPoints.begin(), vertxPoints.end(), sitesOrdered);
    sortedVertx.push_back(vertxPoints[0]);
    for (Point2& s : vertxPoints) 
    {
        if (s != sortedVertx.back())
        {
            sortedVertx.push_back(s);
        }
    }
    //compare cp;
    vertxMinX = sortedVertx[0].x;
    vertxMinY = sortedVertx[0].y;
//    bool vertxOrdered(const Point2 & s1, const Point2 & s2);
    std::sort(sortedVertx.begin(), sortedVertx.end(), vertxOrdered);
}

//Generate Voronoi form porous
void Porous2D::GenVoronoi(NXOpen::Part* workPart)
{
//    theSession->ListingWindow()->Open();
    //Set Voronoi parameters
    Porous2D::particleNumber = Porous2D::integerParticleNumber->Value();

    int sumVertxNum = 0;
    std::vector<double>sitesX;
    std::vector<double>sitesY;
    std::vector<Point2>sites;
    std::vector<Point2>vertxStart;
    std::vector<Point2>vertxEnd;
    std::vector<int> edgeNumber;
    genVertexPoints(sites, vertxStart, vertxEnd, edgeNumber); 
    std::vector<NXOpen::Scalar*> cellScalarX1;
    std::vector<NXOpen::Scalar*> cellScalarY1;
    std::vector<NXOpen::Scalar*> cellScalarZ1;
    std::vector<NXOpen::Point*> cellPoints;
    for (int i = 0; i < sites.size(); i++)
    {
        sitesX.push_back(sites[i].x);
        sitesY.push_back(sites[i].y);
    }
	UF_UI_write_listing_window("====================================================================\n");
    UF_UI_write_listing_window("==========================Voronoi Check ============================\n");
	UF_UI_write_listing_window("====================================================================\n");

    for (int cellIndx = 0; cellIndx < Porous2D::particleNumber; cellIndx++)
    {
        //Initialize StudioSplineBuilderEx tools
        NXOpen::NXObject* nullNXOpen_NXObject(NULL);
        NXOpen::Features::StudioSplineBuilderEx* studioSplineBuilderEx1;
        studioSplineBuilderEx1 = workPart->Features()->CreateStudioSplineBuilderEx(nullNXOpen_NXObject);
        //----Set reference plane
        NXOpen::Point3d origin1(0.0, 0.0, 0.0);
        NXOpen::Vector3d normal1(0.0, 0.0, 1.0);
        NXOpen::Plane* plane1;
        plane1 = workPart->Planes()->CreatePlane(origin1, normal1, NXOpen::SmartObject::UpdateOptionWithinModeling);
        studioSplineBuilderEx1->SetDrawingPlane(plane1);
        //----Set movement plane
        NXOpen::Point3d origin2(0.0, 0.0, 0.0);
        NXOpen::Vector3d normal2(0.0, 0.0, 1.0);
        NXOpen::Plane* plane2;
        plane2 = workPart->Planes()->CreatePlane(origin2, normal2, NXOpen::SmartObject::UpdateOptionWithinModeling);
        studioSplineBuilderEx1->SetMovementPlane(plane2);
        //Set spline parameters
        studioSplineBuilderEx1->OrientExpress()->SetReferenceOption(NXOpen::GeometricUtilities::OrientXpressBuilder::ReferenceWcsDisplayPart);
        studioSplineBuilderEx1->SetDrawingPlaneOption(NXOpen::Features::StudioSplineBuilderEx::DrawingPlaneOptionsXY);
        studioSplineBuilderEx1->SetMovementMethod(NXOpen::Features::StudioSplineBuilderEx::MovementMethodTypeView);
        studioSplineBuilderEx1->SetType(NXOpen::Features::StudioSplineBuilderEx::TypesByPoles);
        studioSplineBuilderEx1->SetDegree(Porous2D::integerBSplineOrder->Value());
        studioSplineBuilderEx1->SetPeriodic(true);
        studioSplineBuilderEx1->OrientExpress()->SetAxisOption(NXOpen::GeometricUtilities::OrientXpressBuilder::AxisPassive);
        studioSplineBuilderEx1->OrientExpress()->SetPlaneOption(NXOpen::GeometricUtilities::OrientXpressBuilder::PlanePassive);
        studioSplineBuilderEx1->SetInputCurveOption(NXOpen::Features::StudioSplineBuilderEx::InputCurveOptionsHide);
        studioSplineBuilderEx1->SetMatchKnotsType(NXOpen::Features::StudioSplineBuilderEx::MatchKnotsTypesNone);
        //Define GeometricConstraintData features for containning controlpoints
        std::vector<NXOpen::Features::GeometricConstraintData*> geometricConstraintData;
        //Set B spline controlpoints' definition
        std::vector<NXOpen::Scalar*> scalarX1;
        std::vector<NXOpen::Scalar*> scalarY1;
        std::vector<NXOpen::Scalar*> scalarZ1;
        std::vector<NXOpen::Point*> setPoints;
        //----Define temp parameters for B spline Scalars
        std::vector<double> xScalar;
        std::vector<double> yScalar;
        std::vector<double> zScalar;
        std::vector<Point2> vertxPoints;
        std::vector<Point2> sortedVertx;

        cellScalarX1.push_back(workPart->Scalars()->CreateScalar(sitesX[cellIndx], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
        cellScalarY1.push_back(workPart->Scalars()->CreateScalar(sitesY[cellIndx], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
        cellScalarZ1.push_back(workPart->Scalars()->CreateScalar(0.0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
        cellPoints.push_back(workPart->Points()->CreatePoint(cellScalarX1[cellIndx],cellScalarY1[cellIndx],cellScalarZ1[cellIndx],NXOpen::SmartObject::UpdateOptionWithinModeling));
        cellPoints[cellIndx]->SetVisibility(NXOpen::SmartObject::VisibilityOptionVisible);

        UF_UI_write_listing_window("-------------------------- cell info start -------------------------\n");
        char tempString[256];
        std::sprintf(tempString, "->\tCellIndex:%d\tCells' sites:(%f,%f)\n", cellIndx, sitesX[cellIndx], sitesY[cellIndx]);
        UF_UI_write_listing_window(tempString);
        std::sprintf(tempString, "->\tCells' edge number:%d\n", edgeNumber[cellIndx]);
        UF_UI_write_listing_window(tempString);
//        std::sprintf(tempString, "->\tCells' vertices number:%d\n", (int)(diagram->vertices.size()));
//        UF_UI_write_listing_window(tempString);
        if (edgeNumber[cellIndx] > 2)
        {
            for (int vertxIndx = 0; vertxIndx  < edgeNumber[cellIndx]; vertxIndx++)
            {
                vertxPoints.push_back(vertxStart[sumVertxNum + vertxIndx]);
                vertxPoints.push_back(vertxEnd[sumVertxNum + vertxIndx]);
            }
            orderVertxPoints(vertxPoints,sortedVertx);
            for (int vertxIndx = 0; vertxIndx  < edgeNumber[cellIndx]; vertxIndx++)
            {
////                xScalar.push_back(vertxPoints[sumVertxNum + vertxIndx].x);
////                yScalar.push_back(vertxPoints[sumVertxNum + vertxIndx].y);
////                zScalar.push_back(0.0);
                xScalar.push_back(sortedVertx[vertxIndx].x);
                yScalar.push_back(sortedVertx[vertxIndx].y);
                zScalar.push_back(0.0);
                std::sprintf(tempString, "->\tVertxIndex:%d\tvertxPoints:(%f,%f)\tsortedPoints:(%f,%f)\n", vertxIndx,vertxPoints[vertxIndx].x,vertxPoints[vertxIndx].y,xScalar[vertxIndx],yScalar[vertxIndx]);
                UF_UI_write_listing_window(tempString);
            }
        sumVertxNum = edgeNumber[cellIndx] + sumVertxNum;
        //Get set points
        for (int i = 0; i < edgeNumber[cellIndx]; i++)
        {
            scalarX1.push_back(workPart->Scalars()->CreateScalar(xScalar[i], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
            scalarY1.push_back(workPart->Scalars()->CreateScalar(yScalar[i], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
            scalarZ1.push_back(workPart->Scalars()->CreateScalar(zScalar[i], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
            setPoints.push_back(workPart->Points()->CreatePoint(scalarX1[i], scalarY1[i], scalarZ1[i], NXOpen::SmartObject::UpdateOptionWithinModeling));
            geometricConstraintData.push_back(studioSplineBuilderEx1->ConstraintManager()->CreateGeometricConstraintData());
            geometricConstraintData[i]->SetPoint(setPoints[i]);
            studioSplineBuilderEx1->ConstraintManager()->Append(geometricConstraintData[i]);
            studioSplineBuilderEx1->Evaluate();
        }
        //Commit parameters to build spline
        NXOpen::NXObject* nXObjectSpline;
        nXObjectSpline = studioSplineBuilderEx1->Commit();
        //----Get particle curves' objects
        Porous2D::particleObject.push_back(nXObjectSpline);
        //----Get particle curves' features
        Porous2D::splineFeature = dynamic_cast<NXOpen::Features::StudioSpline*>(nXObjectSpline);
        Porous2D::splineFeatureCollector.push_back(splineFeature);
        //Free memory
        studioSplineBuilderEx1->Destroy();
        }
    }
}

double normalize(double in, int dimension) {
	return in / (float)dimension*1.8 - 0.9;
}

void genRandomSites(std::vector<Point2>& sites, BoundingBox& bbox, unsigned int numSites) {
    std::vector<Point2> tmpSites;

    tmpSites.reserve(numSites);
    sites.reserve(numSites);

    Point2 s;

    srand(std::clock());
    for (unsigned int i = 0; i < numSites; ++i)
    {
        s.x = 1 + (rand() / (double)RAND_MAX) * ((bbox.xR-bbox.xL) - 2);
        s.y = 1 + (rand() / (double)RAND_MAX) * ((bbox.yT-bbox.yB) - 2);
        tmpSites.push_back(s);
    }
    //remove any duplicates that exist
    std::sort(tmpSites.begin(), tmpSites.end(), sitesOrdered);
    sites.push_back(tmpSites[0]);
    for (Point2& s : tmpSites) 
    {
        if (s != sites.back())
        {
            sites.push_back(s);
        }
    }
}

void Porous2D::genVertexPoints(std::vector<Point2>& sites, std::vector<Point2>& vertxStart,std::vector<Point2>&vertxEnd,std::vector<int>& edgeNumber)
{
	UF_UI_write_listing_window("====================================================================\n");
    UF_UI_write_listing_window("==========================Voronoi Compute===========================\n");
	UF_UI_write_listing_window("====================================================================\n");
	VoronoiDiagramGenerator vdg = VoronoiDiagramGenerator();
    Diagram* diagram = nullptr;
    double diamentionX0 = Porous2D::pointSheetStart->Point().X;
    double diamentionY0 = Porous2D::pointSheetStart->Point().Y;
    double diamentionXmax = Porous2D::expressionFaceLength->Value();
    double diamentionYmax = Porous2D::expressionFaceWidth->Value();

	BoundingBox bbox(diamentionX0,diamentionXmax,diamentionY0,diamentionYmax);
    unsigned int nPoints = Porous2D::integerParticleNumber->Value();
    std::vector<Point2> randSites;
    bool startOver = true;
    bool relaxForever = false;
    int relax = 0;
    Point2 startPoints;
    Point2 endPoints;
    if (startOver)
    {
    	genRandomSites(randSites, bbox, nPoints);
    	diagram = vdg.compute(randSites, bbox);
    }
    if (relax || relaxForever) 
    {
        Diagram* prevDiagram = diagram;
        diagram = vdg.relax();
        delete prevDiagram;
    
        if (diagram->cells.size() != 4) int x = 0;
        --relax;
        if (relax < 0) relax = 0;
    }

    UF_UI_write_listing_window("------------------------ diagram info start ------------------------\n");
    char tempString[256];
    std::sprintf(tempString, "->\tCells' number:%d\n", (int)(diagram->cells.size()));
    UF_UI_write_listing_window(tempString);
    std::sprintf(tempString, "->\tCells' edge number:%d\n", (int)(diagram->edges.size()));
    UF_UI_write_listing_window(tempString);
    std::sprintf(tempString, "->\tCells' vertices number:%d\n", (int)(diagram->vertices.size()));
    UF_UI_write_listing_window(tempString);
    int cellIndex= 0;
    for (Cell* c : diagram->cells)
    {
        Point2& p = c->site.p;
        sites.push_back(p);
        edgeNumber.push_back(c->halfEdges.size());
    	UF_UI_write_listing_window("------------------------- cells info start -------------------------\n");
        sprintf(tempString, "CellIndex:%d\tCells' sites:(%f,%f)\n", cellIndex, p.x, p.y);
        UF_UI_write_listing_window(tempString);
        sprintf(tempString, "->\tCells' halfedges' number:%d\n", (int)(c->halfEdges.size()));
        UF_UI_write_listing_window(tempString);
        for (HalfVoronoiEdge* ve : c->halfEdges)
        {
            startPoints.x = ve->edge->vertA->x;
            startPoints.y = ve->edge->vertA->y;
            endPoints.x = ve->edge->vertB->x;
            endPoints.y = ve->edge->vertB->y;
            vertxStart.push_back(startPoints);
            vertxEnd.push_back(endPoints);
            sprintf(tempString, "--->\tVertexBeginPoints:(%f,%f)\tVertexEndPoints:(%f,%f)\n", startPoints.x, startPoints.y, endPoints.x, endPoints.y);
            UF_UI_write_listing_window(tempString);
        }
     	UF_UI_write_listing_window("------------------------- cells info stop --------------------------\n");
        cellIndex++;
    }
    UF_UI_write_listing_window("------------------------ diagram info stop -------------------------\n");
    delete diagram;
}
#endif //POROUS2D_H_INCLUDED



////    	startOver = false;
////    	relaxForever = false;
////    	relax = 0;

////    	duration = 1000 * (std::clock() - start) / (double)CLOCKS_PER_SEC;
//    std::vector<NXOpen::Point *> sites;
//    if (relax || relaxForever) {
//    for (VoronoiEdge* e : diagram->edges)
//    {
//        if (e->vertA && e->vertB)
//        {
//            Point2& p1 = *e->vertA;
//            Point2& p2 = *e->vertB;
//            (*vertexX).push_back(p1.x);
//            (*vertexY).push_back(p1.y);
//        }
//    }

