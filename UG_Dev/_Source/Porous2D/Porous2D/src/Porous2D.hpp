//==============================================================================
//  WARNING!!  This file is overwritten by the Block Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  G:\RPWorkspace\PorousGen\UG_Dev\Application\Porous2D.hpp
//
//        This file was generated by the NX Block Styler
//        Created by: RenPeng
//              Version: NX 1919
//              Date: 12-15-2020  (Format: mm-dd-yyyy)
//              Time: 16:09
//
//==============================================================================

#ifndef POROUS2D_H_INCLUDED
#define POROUS2D_H_INCLUDED

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <cmath>
#include <ctime>
#include <random>
#include <sstream>
#include "../include/UG-Dev/HuNXOpen.h"
#include "../include/UG-Dev/uf_all.h"
#include "../include/Voronoi/Voronoi_all.h"
#include "../include/GlobalParameters.h"

//------------------------------------------------------------------------------
//Bit Option for Property: SnapPointTypesEnabled
//------------------------------------------------------------------------------
#define              SnapPointTypesEnabled_UserDefined (1 << 0);
#define                 SnapPointTypesEnabled_Inferred (1 << 1);
#define           SnapPointTypesEnabled_ScreenPosition (1 << 2);
#define                 SnapPointTypesEnabled_EndPoint (1 << 3);
#define                 SnapPointTypesEnabled_MidPoint (1 << 4);
#define             SnapPointTypesEnabled_ControlPoint (1 << 5);
#define             SnapPointTypesEnabled_Intersection (1 << 6);
#define                SnapPointTypesEnabled_ArcCenter (1 << 7);
#define            SnapPointTypesEnabled_QuadrantPoint (1 << 8);
#define            SnapPointTypesEnabled_ExistingPoint (1 << 9);
#define             SnapPointTypesEnabled_PointonCurve (1 <<10);
#define           SnapPointTypesEnabled_PointonSurface (1 <<11);
#define         SnapPointTypesEnabled_PointConstructor (1 <<12);
#define     SnapPointTypesEnabled_TwocurveIntersection (1 <<13);
#define             SnapPointTypesEnabled_TangentPoint (1 <<14);
#define                    SnapPointTypesEnabled_Poles (1 <<15);
#define         SnapPointTypesEnabled_BoundedGridPoint (1 <<16);
#define         SnapPointTypesEnabled_FacetVertexPoint (1 <<17);
#define            SnapPointTypesEnabled_DefiningPoint (1 <<18);
//------------------------------------------------------------------------------
//Bit Option for Property: SnapPointTypesOnByDefault
//------------------------------------------------------------------------------
#define          SnapPointTypesOnByDefault_UserDefined (1 << 0);
#define             SnapPointTypesOnByDefault_Inferred (1 << 1);
#define       SnapPointTypesOnByDefault_ScreenPosition (1 << 2);
#define             SnapPointTypesOnByDefault_EndPoint (1 << 3);
#define             SnapPointTypesOnByDefault_MidPoint (1 << 4);
#define         SnapPointTypesOnByDefault_ControlPoint (1 << 5);
#define         SnapPointTypesOnByDefault_Intersection (1 << 6);
#define            SnapPointTypesOnByDefault_ArcCenter (1 << 7);
#define        SnapPointTypesOnByDefault_QuadrantPoint (1 << 8);
#define        SnapPointTypesOnByDefault_ExistingPoint (1 << 9);
#define         SnapPointTypesOnByDefault_PointonCurve (1 <<10);
#define       SnapPointTypesOnByDefault_PointonSurface (1 <<11);
#define     SnapPointTypesOnByDefault_PointConstructor (1 <<12);
#define SnapPointTypesOnByDefault_TwocurveIntersection (1 <<13);
#define         SnapPointTypesOnByDefault_TangentPoint (1 <<14);
#define                SnapPointTypesOnByDefault_Poles (1 <<15);
#define     SnapPointTypesOnByDefault_BoundedGridPoint (1 <<16);
#define     SnapPointTypesOnByDefault_FacetVertexPoint (1 <<17);
#define        SnapPointTypesOnByDefault_DefiningPoint (1 <<18);
//------------------------------------------------------------------------------
// Namespaces needed for following template
//------------------------------------------------------------------------------
using namespace std;
using namespace NXOpen;
using namespace NXOpen::BlockStyler;

class DllExport Porous2D
{
    // class members
public:
    static Session *theSession;
    static UI *theUI;
    Porous2D();
    ~Porous2D();
    int Show();
    
    //----------------------- BlockStyler Callback Prototypes ---------------------
    // The following member function prototypes define the callbacks 
    // specified in your BlockStyler dialog.  The empty implementation
    // of these prototypes is provided in the Porous2D.cpp file. 
    // You are REQUIRED to write the implementation for these functions.
    //------------------------------------------------------------------------------
    void initialize_cb();
    void dialogShown_cb();
    int apply_cb();
    int ok_cb();
    int update_cb(NXOpen::BlockStyler::UIBlock* block);
    PropertyList* GetBlockProperties(const char *blockID);
    
    //Add for PorousTools addon by RP
    //--Set porous sheet global object
    NXOpen::NXObject* SheetObject;
    NXOpen::NXObject* porousSheetObject;
    NXOpen::NXObject* thickenSheetObject;
    //--Set porous bodys
    NXOpen::Body* sheetBodys;
    std::vector<NXOpen::Body*> sheetBodysCollector;
    //--Set AssociativeArc global parameters
    std::vector<NXOpen::NXObject*> particleObject;
    NXOpen::Features::AssociativeArc* arcFeature;
    std::vector<NXOpen::Features::AssociativeArc*>arcFeatureCollector;
    //--Set Spline global parameters
    NXOpen::Features::StudioSpline* splineFeature;
    std::vector<NXOpen::Features::StudioSpline*>splineFeatureCollector;
    //--Set particle center point global parameters
    std::vector<NXOpen::Point*>centerPointCollector;
    //--Set helpPoint used in TrimSheetBodys to get curve feature
    NXOpen::Point3d helpPoint;
    std::vector<NXOpen::Point3d>helpPointCollector;
    //--Set trimsheet body
    NXOpen::Body* porousBodys2D;
    std::vector<NXOpen::Body*> porousBodys2DCollector;

 //   enum Enumcomp {Clockwise,CounterClockwise};
    int particleNumber;
    int xNodeNumber;
    int yNodeNumber;

//    class Porous2D::compare {};
    double vertxMinX, vertxMinY;

//    sheet size parameters
    double sheetLength = 0;
    double sheetWidth = 0;
// particle diameter
    double particleDiameter;
    //Set log file
    ofstream outf;

    void GenPorousSheet(NXOpen::Part* workPart);
    void GenParticleCurve(NXOpen::Part* workPart);
    double GetRandomCoordinate(NXOpen::Part* workPart, string direction);
    int GetRandomNode(NXOpen::Part* workPart, std::string direction);
    void TrimPorousSheet(NXOpen::Part* workPart);
    void GenPorous3D(NXOpen::Part* workPart);

    void GenRandom(NXOpen::Part* workPart);
    void GenSquare(NXOpen::Part* workPart);
    void GenHexagon(NXOpen::Part* workPart);
    void GenVoronoi(NXOpen::Part* workPart);
    void MeshSheet(NXOpen::Part* workPart);
    void SaveAsIGES(NXOpen::Part* workPart);
//    void genVertexPoints(NXOpen::Part* workPart);
//    void Porous2D::genVertexPoints(Diagram* diagram);
//    void genVertexPoints(std::vector<double>* sitesX, std::vector<double>* sitesY);
    void genVertexPoints(std::vector<Point2>& sites, std::vector<Point2>& vertxStart,std::vector<Point2>&vertxEnd,std::vector<int>& edgeNumber);

//    bool vertxOrdered(const Point2& s1, const Point2& s2);
//    void orderVertxPoints(std::vector<Point2>& vertxPoints);
    //void orderVertxPoints(std::vector<Point2>& vertxPoints, double& vertxMinX,double& vertxMinY);

    std::vector<NXOpen::Point*> nodeMesh;
    std::vector<double>nodeMeshX;
    std::vector<double>nodeMeshY;

private:
    const char* theDlxFileName;
    NXOpen::BlockStyler::BlockDialog* theDialog;
    NXOpen::BlockStyler::Group* groupSheetStartPoint;// Block type: Group
    NXOpen::BlockStyler::SpecifyPoint* pointSheetStart;// Block type: Specify Point
    NXOpen::BlockStyler::Group* groupShape;// Block type: Group
    NXOpen::BlockStyler::Enumeration* enumParticleShape;// Block type: Enumeration
    NXOpen::BlockStyler::Group* groupGenMethod;// Block type: Group
    NXOpen::BlockStyler::Enumeration* enumGenMethod;// Block type: Enumeration
    NXOpen::BlockStyler::Toggle* toggleMeshRandom;// Block type: Toggle
    NXOpen::BlockStyler::Toggle* togglePaper;// Block type: Toggle
    NXOpen::BlockStyler::Toggle* toggleOutFluid;// Block type: Toggle
    NXOpen::BlockStyler::Group* groupSize;// Block type: Group
    NXOpen::BlockStyler::TabControl* tabControl1;// Block type: Tabs Page
    NXOpen::BlockStyler::Group* tabPage2;
    NXOpen::BlockStyler::ExpressionBlock* expressionFaceLength;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionFaceWidth;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionParticleSize;// Block type: Expression
    NXOpen::BlockStyler::Group* tabPage3;
    NXOpen::BlockStyler::ExpressionBlock* expressionBasisWeight;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionDryContentFinal;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionDryContentNow;// Block type: Expression
    NXOpen::BlockStyler::Group* tabPage4;
    NXOpen::BlockStyler::ExpressionBlock* expressionLenDensity;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionCelDiameter;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionCelLength;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionLenWidRatio;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionSheetLen;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionComRatio;// Block type: Expression
    NXOpen::BlockStyler::Group* groupParticle;// Block type: Group
    NXOpen::BlockStyler::TabControl* tabControl;// Block type: Tabs Page
    NXOpen::BlockStyler::Group* tabPage;
    NXOpen::BlockStyler::IntegerBlock* integerParticleNumber;// Block type: Integer
    NXOpen::BlockStyler::DoubleBlock* doublePorousRatio;// Block type: Double
    NXOpen::BlockStyler::Toggle* toggleUsePorousRatio;// Block type: Toggle
    NXOpen::BlockStyler::Group* tabPageVoronoi;
    NXOpen::BlockStyler::IntegerBlock* integerBSplineOrder;// Block type: Integer
    NXOpen::BlockStyler::IntegerBlock* integerScaleRatio;// Block type: Integer
    NXOpen::BlockStyler::Toggle* toggleScale;// Block type: Toggle
    NXOpen::BlockStyler::Group* tabPage1;
    NXOpen::BlockStyler::ExpressionBlock* expressionRowGap;// Block type: Expression
    NXOpen::BlockStyler::ExpressionBlock* expressionColumGap;// Block type: Expression
    NXOpen::BlockStyler::Group* groupOption;// Block type: Group
    NXOpen::BlockStyler::Button* buttonGenSheet;// Block type: Button
    NXOpen::BlockStyler::Button* buttonGenParticle;// Block type: Button
    NXOpen::BlockStyler::Button* buttonTrimParticle;// Block type: Button
    NXOpen::BlockStyler::Button* buttonGen3D;// Block type: Button
    NXOpen::BlockStyler::Button* buttonSaveAsIges;// Block type: Button
    NXOpen::BlockStyler::Button* buttonOnekeyGen;// Block type: Button
    NXOpen::BlockStyler::Group* groupSet;// Block type: Group
    NXOpen::BlockStyler::Toggle* togglePrintInfo;// Block type: Toggle
    NXOpen::BlockStyler::Toggle* toggleWriteFile;// Block type: Toggle
    NXOpen::BlockStyler::FolderSelection* nativeFolderBrowser0;// Block type: NativeFolderBrowser
};

//Generate porous sheets
void Porous2D::GenPorousSheet(NXOpen::Part* workPart)
{
    if (Porous2D::togglePaper->Value() == false)
    {
        //Four points creat plane
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->生成片体：普通方式\n");
            UF_UI_write_listing_window("->\t开始四点成面...\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->生成片体：普通方式" << endl;
            Porous2D::outf << "->\t开始四点成面..." << endl;
        }
        //Initialize FourPointSurfaceBuilder
        NXOpen::FourPointSurfaceBuilder* fourPointSurfaceBuilder1;
        fourPointSurfaceBuilder1 = workPart->Bodies()->CreateFourPointSurfaceBuilder();
        //Create set points of surface
        //----Set compress ratio
        double comRatio = Porous2D::expressionComRatio->Value();
        //----Judge if the generation method need use compress ratio
        bool methodJudge = (std::string)(Porous2D::enumGenMethod->ValueAsString()).GetText() == "Hexagon" || (std::string)(Porous2D::enumGenMethod->ValueAsString()).GetText() == "Square";
        if (Porous2D::toggleOutFluid->Value() == false && methodJudge)
        {
            comRatio = 1.0;
        }
        //----Set setpoint1
        NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
        fourPointSurfaceBuilder1->SetPoint1(setPoint1);
        double x0 = setPoint1->Coordinates().X;
        double y0 = setPoint1->Coordinates().Y;
        double z0 = setPoint1->Coordinates().Z;
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t第一点：[x: %f, y: %f, z: %f]\n",x0,y0,z0);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t第一点：[x: " << x0 << ", y: " << y0 << ", z: " << z0 << endl;
        }
        //----Set setpoint2
        NXOpen::Scalar* scalar21;
        scalar21 = workPart->Scalars()->CreateScalar(x0 + expressionFaceLength->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar22;
        scalar22 = workPart->Scalars()->CreateScalar(y0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar23;
        scalar23 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint2 = workPart->Points()->CreatePoint(scalar21, scalar22, scalar23, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint2(setPoint2);
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t第二点：[x: %f, y: %f, z: %f]\n",setPoint2->Coordinates().X,setPoint2->Coordinates().Y,setPoint2->Coordinates().Z);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t第二点：[x: " << setPoint2->Coordinates().X << ", y: " << setPoint2->Coordinates().Y << ", z: " << setPoint2->Coordinates().Z << endl;
        }
        //----Set setpoint3
        NXOpen::Scalar* scalar31;
        scalar31 = workPart->Scalars()->CreateScalar(x0 + expressionFaceLength->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar32;
        scalar32 = workPart->Scalars()->CreateScalar(y0 + expressionFaceWidth->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar33;
        scalar33 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint3 = workPart->Points()->CreatePoint(scalar31, scalar32, scalar33, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint3(setPoint3);
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t第三点：[x: %f, y: %f, z: %f]\n",setPoint3->Coordinates().X,setPoint3->Coordinates().Y,setPoint3->Coordinates().Z);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t第三点：[x: " << setPoint3->Coordinates().X << ", y: " << setPoint3->Coordinates().Y << ", z: " << setPoint3->Coordinates().Z << endl;
        }
        //----Set setpoint4
        NXOpen::Scalar* scalar41;
        scalar41 = workPart->Scalars()->CreateScalar(x0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar42;
        scalar42 = workPart->Scalars()->CreateScalar(y0 + expressionFaceWidth->Value(), NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar43;
        scalar43 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint4 = workPart->Points()->CreatePoint(scalar41, scalar42, scalar43, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint4(setPoint4);
        //----Compute sheet length and sheet width
        Porous2D::sheetLength = max(abs(setPoint2->Coordinates().X - setPoint1->Coordinates().X),abs(setPoint4->Coordinates().Y - setPoint1->Coordinates().Y));
        Porous2D::sheetWidth = min(abs(setPoint2->Coordinates().X - setPoint1->Coordinates().X),abs(setPoint4->Coordinates().Y - setPoint1->Coordinates().Y));
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t第四点：[x: %f, y: %f, z: %f]\n",setPoint4->Coordinates().X,setPoint4->Coordinates().Y,setPoint4->Coordinates().Z);
            UF_UI_write_listing_window(tempString);
            std::sprintf(tempString, "->\t片体长：%f; 片体宽：%f\n",Porous2D::sheetLength,Porous2D::sheetWidth);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t第四点：[x: " << setPoint4->Coordinates().X << ", y: " << setPoint4->Coordinates().Y << ", z: " << setPoint4->Coordinates().Z << endl;
        }
        //Create surface object
        NXOpen::NXObject* nXObjectSheet;
        nXObjectSheet = fourPointSurfaceBuilder1->Commit();
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t完成四点成面！\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t完成四点成面！" << endl;
        }
        //Pass to global parameters
        //----Get trim taget object
        Porous2D::SheetObject = nXObjectSheet;
        //----Get trim taget sheet bodies
        Porous2D::sheetBodys = dynamic_cast<NXOpen::Body*>(nXObjectSheet);
        Porous2D::sheetBodysCollector.push_back(Porous2D::sheetBodys);
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t面体存储...\n");
            NXOpen::NXString sheetID = Porous2D::SheetObject->JournalIdentifier();
            string ID = sheetID.GetLocaleText();
            string ss = "->\tsheetID:\t";
            string printID = ss + ID + "\n";
            UF_UI_write_listing_window(printID.c_str());
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t面体存储..." << endl;
            NXOpen::NXString sheetID = Porous2D::SheetObject->JournalIdentifier();
            string printID = sheetID.GetLocaleText();
            Porous2D::outf << "->\tsheetID:" << printID << endl;
        }
        //Free memory
        fourPointSurfaceBuilder1->Destroy();
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t内存释放！\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t内存释放！" << endl;
        }
    }
    else
    {
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->生成片体：纸幅方式\n");
            UF_UI_write_listing_window("->\t开始四点成面...\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->生成片体：普通方式" << endl;
            Porous2D::outf << "->\t开始四点成面..." << endl;
        }
        //Four points creat plane
        //Initialize FourPointSurfaceBuilder
        NXOpen::FourPointSurfaceBuilder* fourPointSurfaceBuilder1;
        fourPointSurfaceBuilder1 = workPart->Bodies()->CreateFourPointSurfaceBuilder();
        //Create set points of surface
        //----Set compress ratio
        double comRatio = Porous2D::expressionComRatio->Value();
        //----Set setpoint1
        NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
        fourPointSurfaceBuilder1->SetPoint1(setPoint1);
        double x0 = setPoint1->Coordinates().X;
        double y0 = setPoint1->Coordinates().Y;
        double z0 = setPoint1->Coordinates().Z;
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t第一点：[x: %f, y: %f, z: %f]\n",x0,y0,z0);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t第一点：[x: " << x0 << ", y: " << y0 << ", z: " << z0 << "]" << endl;
        }
        //----Get sheet height
        Porous2D::sheetWidth = Porous2D::expressionBasisWeight->Value() /1000.0 * Porous2D::expressionDryContentFinal->Value() / 100.0\
            / (1.0 - Porous2D::doublePorousRatio->Value()) * (1.0 / 1.5e3 + (1.0 - Porous2D::expressionDryContentNow->Value() / 100.0) \
                / (Porous2D::expressionDryContentNow->Value() / 100.0) / 1e3) * 1000.0;
        Porous2D::sheetLength = Porous2D::sheetWidth * Porous2D::expressionLenWidRatio->Value();
        //----Set setpoint2
        NXOpen::Scalar* scalar21;
        scalar21 = workPart->Scalars()->CreateScalar(x0 + Porous2D::sheetLength, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar22;
        scalar22 = workPart->Scalars()->CreateScalar(y0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar23;
        scalar23 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint2 = workPart->Points()->CreatePoint(scalar21, scalar22, scalar23, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint2(setPoint2);
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t第二点：[x: %f, y: %f, z: %f]\n",setPoint2->Coordinates().X,setPoint2->Coordinates().Y,setPoint2->Coordinates().Z);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t第二点：[x: " << setPoint2->Coordinates().X << ", y: " << setPoint2->Coordinates().Y << ", z: " << setPoint2->Coordinates().Z << "]" << endl;
        }
        //----Set setpoint3
        NXOpen::Scalar* scalar31;
        scalar31 = workPart->Scalars()->CreateScalar(x0 + Porous2D::sheetLength, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar32;
        scalar32 = workPart->Scalars()->CreateScalar(y0 + Porous2D::sheetWidth * comRatio, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar33;
        scalar33 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint3 = workPart->Points()->CreatePoint(scalar31, scalar32, scalar33, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint3(setPoint3);
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t第三点：[x: %f, y: %f, z: %f]\n",setPoint3->Coordinates().X,setPoint3->Coordinates().Y,setPoint3->Coordinates().Z);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t第三点：[x: " << setPoint3->Coordinates().X << ", y: " << setPoint3->Coordinates().Y << ", z: " << setPoint3->Coordinates().Z << "]" << endl;
        }
        //----Set setpoint4
        NXOpen::Scalar* scalar41;
        scalar41 = workPart->Scalars()->CreateScalar(x0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar42;
        scalar42 = workPart->Scalars()->CreateScalar(y0 + Porous2D::sheetWidth * comRatio, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Scalar* scalar43;
        scalar43 = workPart->Scalars()->CreateScalar(z0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
        NXOpen::Point* setPoint4 = workPart->Points()->CreatePoint(scalar41, scalar42, scalar43, NXOpen::SmartObject::UpdateOptionWithinModeling);
        fourPointSurfaceBuilder1->SetPoint4(setPoint4);
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t第四点：[x: %f, y: %f, z: %f]\n",setPoint4->Coordinates().X,setPoint4->Coordinates().Y,setPoint4->Coordinates().Z);
            UF_UI_write_listing_window(tempString);
            std::sprintf(tempString, "->\t片体长：%f; 片体宽：%f -->压缩后宽：%f\n",Porous2D::sheetLength, Porous2D::sheetWidth, comRatio * Porous2D::sheetWidth);
            UF_UI_write_listing_window(tempString);
            std::sprintf(tempString, "->\t压缩系数：%f\n",comRatio);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t第四点：[x: " << setPoint4->Coordinates().X << ", y: " << setPoint4->Coordinates().Y << ", z: " << setPoint4->Coordinates().Z << "]" << endl;
            Porous2D::outf << "->\t片体长：" <<  Porous2D::sheetLength << "片体宽：" << Porous2D::sheetWidth << " -->压缩后宽：" << comRatio * Porous2D::sheetWidth << endl;
            Porous2D::outf << "->\t压缩系数：" <<  comRatio << endl;
        }
        //Create surface object
        NXOpen::NXObject* nXObjectSheet;
        nXObjectSheet = fourPointSurfaceBuilder1->Commit();
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t完成四点成面！\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t完成四点成面！" << endl;
        }
        //Pass to global parameters
        //----Get trim taget object
        Porous2D::SheetObject = nXObjectSheet;
        //----Get trim taget sheet bodies
        Porous2D::sheetBodys = dynamic_cast<NXOpen::Body*>(nXObjectSheet);
        Porous2D::sheetBodysCollector.push_back(Porous2D::sheetBodys);
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t面体存储...\n");
            NXOpen::NXString sheetID = Porous2D::SheetObject->JournalIdentifier();
            string ID = sheetID.GetLocaleText();
            string ss = "->\tsheetID:\t";
            string printID = ss + ID + "\n";
            UF_UI_write_listing_window(printID.c_str());
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t面体存储..." << endl;
            NXOpen::NXString sheetID = Porous2D::SheetObject->JournalIdentifier();
            string printID = sheetID.GetLocaleText();
            Porous2D::outf << "->\tsheetID:" << printID << endl;
        }
        //Free memory
        fourPointSurfaceBuilder1->Destroy();
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t内存释放！\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t内存释放！" << endl;
        }
    }
}

//Generate particles curves
void Porous2D::GenParticleCurve(NXOpen::Part* workPart)
{
    //Create particle boundary curves
    //Create circle center point
    NXOpen::Point3d origin1(0.0, 0.0, 0.0);
    NXOpen::Vector3d normal1(0.0, 0.0, 1.0);
    NXOpen::Plane* plane1;
    plane1 = workPart->Planes()->CreatePlane(origin1, normal1, NXOpen::SmartObject::UpdateOptionWithinModeling);
    //Initialize generation method string
    std::string randomMethod = "Random";
    std::string squareMethod = "Square";
    std::string hexagonMethod = "Hexagon";
    std::string voronoiMethod = "Voronoi";
    NXOpen::NXString genMethod = Porous2D::enumGenMethod->ValueAsString();
    //Judge particle genaration method
    if ((std::string)genMethod.GetText() == randomMethod)
    {
        //Generate random particle curves
        GenRandom(workPart);
    }
    else if ((std::string)genMethod.GetText() == squareMethod)
    {
        //Generate square form particle porous
        GenSquare(workPart);
    }
    else if ((std::string)genMethod.GetText() == hexagonMethod)
    {
        //Generate hexagon form porous
        GenHexagon(workPart);
    }
    else if ((std::string)genMethod.GetText() == voronoiMethod)
    {
        //Generate Voronoi form porous
        GenVoronoi(workPart);
    }
    plane1->DestroyPlane();
}

//Generate random x or y in porous sheet zone
double Porous2D::GetRandomCoordinate(NXOpen::Part* workPart, std::string direction)
{
    NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
    double x0 = setPoint1->Coordinates().X;
    double y0 = setPoint1->Coordinates().Y;
    double z0 = setPoint1->Coordinates().Z;
    double particleSize = Porous2D::expressionParticleSize->Value();
    double xMax = x0 + Porous2D::expressionFaceLength->Value();
    double yMax = y0 + Porous2D::expressionFaceWidth->Value();
    //
    if (direction == "x")
    {
        return ((double)rand() / RAND_MAX) * (xMax - x0 - particleSize) + x0 + particleSize / 2.0;
    }
    else if (direction == "y")
    {
        return ((double)rand() / RAND_MAX) * (yMax - y0 - particleSize) + y0 + particleSize / 2.0;
    }
    else
    {
        uc1601("Error:(GetRandomCoordinate:)Wrong direction in particle curve genaration!", 1);
        UF_UI_write_listing_window("Error:(GetRandomCoordinate:)Wrong direction in particle curve genaration!\n");
        Porous2D::outf << "Error:(GetRandomCoordinate:)Wrong direction in particle curve genaration!" << endl;
    }
}

//Generate random x or y node number in porous sheet zone
int Porous2D::GetRandomNode(NXOpen::Part* workPart, std::string direction)
{

    if (direction == "x")
    {
        return ((rand() % (Porous2D::xNodeNumber - 1))+1);
    }
    else if (direction == "y")
    {
        return ((rand() % (Porous2D::yNodeNumber - 1))+1);
    }
    else
    {
        uc1601("Error:(GetRandomCoordinate:)Wrong direction in particle curve genaration!", 1);
        UF_UI_write_listing_window("Error:(GetRandomCoordinate:)Wrong direction in particle curve genaration!\n");
        Porous2D::outf << "Error:(GetRandomCoordinate:)Wrong direction in particle curve genaration!" << endl;
    }
}

//Generate random particle mesh
void Porous2D::MeshSheet(NXOpen::Part* workPart)
{
    Porous2D::xNodeNumber = floor(Porous2D::expressionFaceLength->Value() / Porous2D::expressionParticleSize->Value());
    Porous2D::yNodeNumber = floor(Porous2D::expressionFaceWidth->Value() / Porous2D::expressionParticleSize->Value());
    double xNodeLength = Porous2D::expressionFaceLength->Value() / (double)xNodeNumber;
    double yNodeLength = Porous2D::expressionFaceWidth->Value() / (double)yNodeNumber;
    for (int i = 0; i <= xNodeNumber; i++)
    {
        for (int j = 0; j <= yNodeNumber; j++)
        {
            double x0 = Porous2D::pointSheetStart->Point().X;
            double y0 = Porous2D::pointSheetStart->Point().Y;
            double z0 = Porous2D::pointSheetStart->Point().Z;
            Porous2D::nodeMeshX.push_back((double)(i * xNodeLength) + x0);
            Porous2D::nodeMeshY.push_back((double)(j * yNodeLength) + y0);
        }
    }
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        char tempString[256];
        std::sprintf(tempString, "->\t行节点数：%d\t列节点数： %d\n",xNodeNumber,yNodeNumber);
        UF_UI_write_listing_window(tempString);
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t行节点数：" << xNodeNumber << "\t列节点数：" << yNodeNumber << endl;
    }
}

//Trim sheet to get porous 
void Porous2D::TrimPorousSheet(NXOpen::Part* workPart)
{
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->剪切片体：\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->剪切片体：" << endl;
    }
    //Trim sheet to get porous
    //Initialize parameters
    int currentParticleNum = 0;
    NXOpen::NXObject* nullNXOpen_NXObject(NULL);
    //Initialize TrimSheetBuilder
    NXOpen::Features::Feature* nullNXOpen_Features_Feature(NULL);
    NXOpen::Features::TrimSheetBuilder* trimSheetBuilder1;
    trimSheetBuilder1 = workPart->Features()->CreateTrimsheetBuilder(nullNXOpen_Features_Feature);
    trimSheetBuilder1->SetTolerance(0.001);
    trimSheetBuilder1->SetExtendBoundaryObject(true);
    //Set trim taget object
    bool added1;
    added1 = trimSheetBuilder1->TargetBodies()->Add(Porous2D::sheetBodys);
    //Set maintain region referrence point
    NXOpen::Point* point1;
    point1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
    NXOpen::RegionPoint* regionPoint1;
    regionPoint1 = workPart->CreateRegionPoint(point1, Porous2D::sheetBodys);
    trimSheetBuilder1->Regions()->Append(regionPoint1);
    NXOpen::Direction* nullNXOpen_Direction(NULL);
    trimSheetBuilder1->ProjectionDirection()->SetProjectVector(nullNXOpen_Direction);
    //Set trim section
    NXOpen::Section* section1;
    section1 = workPart->Sections()->CreateSection(0.00095, 0.001, 0.050000000000000003);
    section1->SetAllowedEntityTypes(NXOpen::Section::AllowTypesOnlyCurves);
    //Set section as TrimSheetBuilder boundary
    bool added2;
    added2 = trimSheetBuilder1->BoundaryObjects()->Add(section1);
    //----Set curve collector vector 
    std::vector<NXOpen::IBaseCurve*> curves1(Porous2D::particleNumber);
    std::vector<NXOpen::Arc*> arcSelected(Porous2D::particleNumber);
    std::vector<NXOpen::Spline*> splineSelected(Porous2D::particleNumber);
    char tempString[256];
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t循环读取添加特征...\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t循环读取添加特征..." << endl;
    }
    //Set loop
    while (currentParticleNum < Porous2D::particleNumber)
    {
        if ((std::string)(enumGenMethod->ValueAsString().GetText()) == "Voronoi")
        {
            splineSelected[currentParticleNum] = dynamic_cast<NXOpen::Spline*>(splineFeatureCollector[currentParticleNum]->FindObject("CURVE 1"));
            curves1[currentParticleNum] = splineSelected[currentParticleNum];
        }
        else if ((std::string)(enumParticleShape->ValueAsString().GetText()) == "Circle")
        {
            arcSelected[currentParticleNum] = dynamic_cast<NXOpen::Arc*>(Porous2D::arcFeatureCollector[currentParticleNum]->FindObject("CURVE 1"));
            curves1[currentParticleNum] = arcSelected[currentParticleNum];
        }
        //Update particle number
        currentParticleNum++;
    }
    NXOpen::CurveDumbRule* curveDumbRule1;
    curveDumbRule1 = workPart->ScRuleFactory()->CreateRuleBaseCurveDumb(curves1);
    section1->AllowSelfIntersection(true);
    //----Set SelectionIntentRule
    std::vector<NXOpen::SelectionIntentRule*> rules1(1);
    rules1[0] = curveDumbRule1;
    //----Add rules to section
    NXOpen::Point3d helpPointOrigin(0.0, 0.0, 0.0);
    section1->AddToSection(rules1, nullNXOpen_NXObject, nullNXOpen_NXObject, nullNXOpen_NXObject, helpPointOrigin, NXOpen::Section::ModeCreate, false);
    trimSheetBuilder1->ProjectionDirection()->SetProjectVector(nullNXOpen_Direction);
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t剪切...\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t剪切..." << endl;
    }
    //Trim sheet
    NXOpen::NXObject* nXObjectTrimPorousSheet;
    nXObjectTrimPorousSheet = trimSheetBuilder1->Commit();
    //Pass to global parameters
    //----Get porous2D taget object
    Porous2D::porousSheetObject = nXObjectTrimPorousSheet;
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        std::sprintf(tempString, "->\tcurveNum:%I64u\n", curves1.size());
        UF_UI_write_listing_window(tempString);
        //----Find Journalldentifier of sheet body
        NXOpen::NXString sheetID = Porous2D::SheetObject->JournalIdentifier();
        string sID = sheetID.GetLocaleText();
        string sss = "->\tsheetID:\t";
        string sheetPrintID = sss + sID + "\n";
        UF_UI_write_listing_window(sheetPrintID.c_str());
        //----Find Journalldentifier of trim feature of sheet body
        NXOpen::NXString trimSheetID = Porous2D::porousSheetObject->JournalIdentifier();
        string tID = trimSheetID.GetLocaleText();
        string tss = "->\ttrimSheetID:\t";
        string trimSheetPrintID = tss + tID + "\n";
        UF_UI_write_listing_window(trimSheetPrintID.c_str());
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\tcurveNum:" << curves1.size() << endl;
        NXOpen::NXString sheetID = Porous2D::SheetObject->JournalIdentifier();
        string sID = sheetID.GetLocaleText();
        Porous2D::outf << "->\tsheetID:\t" << sID << endl;
        NXOpen::NXString trimSheetID = Porous2D::porousSheetObject->JournalIdentifier();
        string tID = trimSheetID.GetLocaleText();
        Porous2D::outf << "->\ttrimSheetID:\t" << tID << endl;
    }
    //----Get trim taget sheet bodies
    Porous2D::porousBodys2D = dynamic_cast<NXOpen::Body*>(nXObjectTrimPorousSheet);
    Porous2D::porousBodys2DCollector.push_back(Porous2D::porousBodys2D);
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t剪切片体存储...\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t剪切片体存储..." << endl;
    }
    //Free memory
    trimSheetBuilder1->Destroy();
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t内存释放！\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t内存释放！" << endl;
    }
}

//Generate 3D porous medium
void Porous2D::GenPorous3D(NXOpen::Part* workPart)
{
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        char tempString[256];
        UF_UI_write_listing_window("->生成3D介质：\n");
        std::sprintf(tempString, "->\t拉伸长度:%f (mm)\n", Porous2D::expressionSheetLen->Value());
        UF_UI_write_listing_window(tempString);
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->生成3D介质：" << endl;
        Porous2D::outf << "->\t拉伸长度:" << Porous2D::expressionSheetLen->Value() << " (mm)" << endl;
    }
    //Create thickenBuilder to sheet
    NXOpen::Features::Feature *nullNXOpen_Features_Feature(NULL);
    NXOpen::Features::ThickenBuilder *thickenBuilder1;
    thickenBuilder1 = workPart->Features()->CreateThickenBuilder(nullNXOpen_Features_Feature);
    thickenBuilder1->SetTolerance(0.001);
    thickenBuilder1->RegionToPierce()->SetDistanceTolerance(0.001);
    thickenBuilder1->RegionToPierce()->SetChainingTolerance(0.00095);
    //----Find Journalldentifier of sheet body
    NXOpen::NXString sheetID = Porous2D::SheetObject->JournalIdentifier();
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        string ID = sheetID.GetLocaleText();
        string ss = "->\tsheetID:\t";
        string printID = ss + ID + "\n";
        UF_UI_write_listing_window(printID.c_str());
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        string printID = sheetID.GetLocaleText();
        Porous2D::outf << "->\tsheetID:" << printID << endl;
    }
    NXOpen::Body *body1(dynamic_cast<NXOpen::Body *>(workPart->Bodies()->FindObject(sheetID)));
    NXOpen::FaceBodyRule *faceBodyRule1;
    faceBodyRule1 = workPart->ScRuleFactory()->CreateRuleFaceBody(body1);
    std::vector<NXOpen::SelectionIntentRule *> rules1(1);
    rules1[0] = faceBodyRule1;
    thickenBuilder1->FaceCollector()->ReplaceRules(rules1, false);
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        char tempString[256];
        std::sprintf(tempString, "->\t设置拉伸长度:%f (mm)\n", Porous2D::expressionSheetLen->Value());
        UF_UI_write_listing_window(tempString);
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t设置拉伸长度:" << Porous2D::expressionSheetLen->Value() << " (mm)" << endl;
    }
    //----Set distance to thicken
    thickenBuilder1->FirstOffset()->SetValue(Porous2D::expressionSheetLen->Value());
    NXOpen::NXObject *nXObjectThickenSheet;
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t拉伸...\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t拉伸..." << endl;
    }
    nXObjectThickenSheet = thickenBuilder1->Commit();
    Porous2D::thickenSheetObject = nXObjectThickenSheet;
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t拉伸完成！\n");
        //----Find Journalldentifier of sheet body
        NXOpen::NXString thickenSheetID = Porous2D::thickenSheetObject->JournalIdentifier();
        string sID = thickenSheetID.GetLocaleText();
        string sss = "->\tthickenSheetID:\t";
        string sheetPrintID = sss + sID + "\n";
        UF_UI_write_listing_window(sheetPrintID.c_str());
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t拉伸完成！" << endl;
        NXOpen::NXString thickenSheetID = Porous2D::thickenSheetObject->JournalIdentifier();
        string sID = sheetID.GetLocaleText();
        Porous2D::outf << "->\tthickenSheetID:\t" << sID << endl;
    }
    thickenBuilder1->Destroy();
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t内存释放！\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t内存释放！" << endl;
    }
}
//------------------------------------------------------------------------------

//Generate random form porous
void Porous2D::GenRandom(NXOpen::Part* workPart)
{
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->生成颗粒：随机方式\n");
        UF_UI_write_listing_window("->\t开始生成颗粒...\n");
        UF_UI_write_listing_window("->\t生成格式化网格...\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->生成颗粒：随机方式" << endl;
        Porous2D::outf << "->\t开始生成颗粒..." << endl;
        Porous2D::outf << "->\t生成格式化网格..." << endl;
    }
    MeshSheet(workPart);
    //Generate random seed
    std::srand((unsigned)std::time(0));
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t生成随机种子...\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t生成随机种子..." << endl;
    }
    bool randomPR = Porous2D::toggleUsePorousRatio->Value();
    if (randomPR)
    {
        double ratio = Porous2D::doublePorousRatio->Value();
//        double length = Porous2D::expressionFaceLength->Value();
//        double width = Porous2D::expressionFaceWidth->Value();
        Porous2D::sheetLength = Porous2D::expressionFaceLength->Value();
        Porous2D::sheetWidth = Porous2D::expressionFaceWidth->Value();
        double diameter = Porous2D::expressionParticleSize->Value();
        Porous2D::particleNumber = floor((1.0 - ratio) * Porous2D::sheetLength * Porous2D::sheetWidth / (PI * diameter * diameter / 4.0));
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t使用设置孔隙率...\n");
            char tempString[256];
            std::sprintf(tempString, "->\t颗粒数：%d\n",Porous2D::particleNumber);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t使用设置孔隙率..." << endl;
            Porous2D::outf << "->\t颗粒数：" << Porous2D::particleNumber << endl;
        }
    }
    else
    {
        Porous2D::particleNumber = Porous2D::integerParticleNumber->Value();
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t使用设置颗粒数...\n");
            char tempString[256];
            std::sprintf(tempString, "->\t颗粒数：%d\n",Porous2D::particleNumber);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t使用设置颗粒数..." << endl;
            Porous2D::outf << "->\t颗粒数：" << Porous2D::particleNumber << endl;
        }
    }
    //Judge particle shape
    if ((std::string)(Porous2D::enumParticleShape->ValueAsString()).GetText() == "Circle")
    {
        //Create circle center point
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t生成(圆形)颗粒中心点...\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t生成(圆形)颗粒中心点..." << endl;
        }
        char tempString[256];
        //Generate circle particle curves
        for (int i = 0; i < Porous2D::particleNumber; i++)
        {
            //Initialize AssociativeArcBuiler
            NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
            NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
            associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
            //Get random particles' center points 
            //----Get sheet start point's coordinate
            NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(pointSheetStart->Point());
            double x0 = setPoint1->Coordinates().X;
            double y0 = setPoint1->Coordinates().Y;
            double z0 = setPoint1->Coordinates().Z;
            NXOpen::Point* circleCorePoint1;
            double xPick, yPick, zPick;
            if (Porous2D::toggleMeshRandom->Value() == false)
            {
                //----Create random circle center points
                xPick = GetRandomCoordinate(workPart, "x");
                yPick = GetRandomCoordinate(workPart, "y");
                zPick = z0;
                //----Print process to info window
                if (Porous2D::togglePrintInfo->Value() == true)
                {
                    std::sprintf(tempString, "->\t[%d]\t普通随机点\tx: %f, y: %f, z: %f\n",i,xPick,yPick,zPick);
                    UF_UI_write_listing_window(tempString);
                }
                //----Print process to log file
                if (Porous2D::toggleWriteFile->Value() == true)
                {
                    Porous2D::outf << "->\t[" << i << "]\t普通随机点\tx: " << xPick << ", y: " << yPick << ", z: " << zPick << endl;
                }
            }
            else
            {
                int nodeI, nodeJ, nodePick;
                nodeI = GetRandomNode(workPart, "x");
                nodeJ = GetRandomNode(workPart, "y");
                nodePick = nodeI * (Porous2D::yNodeNumber + 1)+ nodeJ + 1;
                xPick = Porous2D::nodeMeshX[(int)(nodePick-1)];
                yPick = Porous2D::nodeMeshY[(int)(nodePick-1)];
                zPick = z0;
                //----Print process to info window
                if (Porous2D::togglePrintInfo->Value() == true)
                {
                    std::sprintf(tempString, "->\t[%d]\t网格点\t[%d,%d]\tx: %f, y: %f, z: %f\n",i,nodeI, nodeJ,xPick,yPick,zPick);
                    UF_UI_write_listing_window(tempString);
                }
                //----Print process to log file
                if (Porous2D::toggleWriteFile->Value() == true)
                {
                    Porous2D::outf << "->\t[" << i << "]\t网格点\t[" << nodeI << "," << nodeJ << "]\tx: " << xPick << ", y: " << yPick << ", z: " << zPick << endl;
                }
            }
            NXOpen::Scalar* scalarX1(NULL);
            scalarX1 = workPart->Scalars()->CreateScalar(xPick, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
            NXOpen::Scalar* scalarY1(NULL);
            scalarY1 = workPart->Scalars()->CreateScalar(yPick, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
            NXOpen::Scalar* scalarZ1(NULL);
            scalarZ1 = workPart->Scalars()->CreateScalar(zPick, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
            circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
            Porous2D::centerPointCollector.push_back(circleCorePoint1);
            //Set AssociativeArcBuilder parameters
            //----Create helpPoints for trim section
            Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + Porous2D::expressionParticleSize->Value() / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
            Porous2D::helpPointCollector.push_back(helpPoint);
            //----Set circle curves' genaration plane
            NXOpen::Vector3d Vector1;
            Vector1 = { 0.0, 0.0, 1.0 };
            //----Open switch to set plane normal direction
            NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
            planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
            associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
            //----Set AssociativeArcBuilder required parameters
            associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
            associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
            associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
            associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
            associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionParticleSize->Value());
            associativeArcBuilder1->Limits()->SetFullCircle(true);
            //Create circle particle curves
            NXOpen::NXObject* nXObjectCircle;
            nXObjectCircle = associativeArcBuilder1->Commit();
            //Pass to global parameters
            //----Get particle curves' objects
            Porous2D::particleObject.push_back(nXObjectCircle);
            //----Get particle curves' features
            Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
            Porous2D::arcFeatureCollector.push_back(arcFeature);
            //Free memory
            associativeArcBuilder1->Destroy();
        }
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t完成中心点与直径成圆！\n");
            UF_UI_write_listing_window("->\t圆线存储...\n");
            UF_UI_write_listing_window("->\t内存释放！\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t完成中心点与直径成圆！" << endl;
            Porous2D::outf << "->\t圆线存储..." << endl;
            Porous2D::outf << "->\t内存释放！" << endl;
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
    {
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t生成(方形)颗粒中心点...\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t生成(方形)颗粒中心点..." << endl;
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
    {
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t生成(三角形)颗粒中心点...\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t生成(三角形)颗粒中心点..." << endl;
        }
    }
}

//Generate square form porous
void Porous2D::GenSquare(NXOpen::Part* workPart)
{
    //----Print process to info window
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->生成颗粒：方形阵列\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->生成颗粒：方形阵列" << endl;
    }
    //Judge particle shape
    if ((std::string)(Porous2D::enumParticleShape->ValueAsString()).GetText() == "Circle")
    {
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t开始生成(圆形)颗粒...\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t开始生成(圆形)颗粒..." << endl;
        }
        //----Get sheet start point's coordinate
        NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
        double x0 = setPoint1->Coordinates().X;
        double y0 = setPoint1->Coordinates().Y;
        double z0 = setPoint1->Coordinates().Z;
        //----Get sheet center point's coordinate
        double xSheetCenter = setPoint1->Coordinates().X + Porous2D::expressionFaceLength->Value() / 2.0;
        double ySheetCenter = setPoint1->Coordinates().Y + Porous2D::expressionFaceWidth->Value() / 2.0;
        double zSheetCenter = setPoint1->Coordinates().Z;
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t片体初始点：\tx: %f\ty: %f\tz: %f\n",x0,y0,z0);
            UF_UI_write_listing_window(tempString);
            std::sprintf(tempString, "->\t片体中心点：\tx: %f\ty: %f\tz: %f\n",xSheetCenter,ySheetCenter,zSheetCenter);
            UF_UI_write_listing_window(tempString);
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t片体初始点：\tx: " << x0 << "\ty: " << y0 << "\tz : " << z0 << endl;
            Porous2D::outf << "->\t片体中心点：\tx: " << xSheetCenter << "\ty: " << ySheetCenter << "\tz : " << zSheetCenter << endl;
        }
        //----Get porous zone boundary start point coordinary
        NXOpen::Point* pointPorousZoneStart;
        double xZoneStart, yZoneStart, zZoneStart;
        double zoneLength, zoneWidth;
        bool changeLenWid = false;
        if (Porous2D::toggleOutFluid->Value() == false)
        {
            xZoneStart = xSheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
            yZoneStart = ySheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
            zZoneStart = zSheetCenter;
            zoneLength = min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
            zoneWidth = zoneLength;
            if (Porous2D::expressionFaceLength->Value() < Porous2D::expressionFaceWidth->Value())
            {
                changeLenWid = true;
            }
            //----Print process to info window
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t流动形式：内流\n");
                char tempString[256];
                std::sprintf(tempString, "->\t介质区初始点：\tx: %f\ty: %f\tz: %f\n",xZoneStart,yZoneStart,zZoneStart);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t介质区长：\t%f\t介质区宽：\t%f\n",zoneLength,zoneWidth);
                UF_UI_write_listing_window(tempString);
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t流动形式：内流" << endl;
                Porous2D::outf << "->\t介质区初始点：\tx: " << xZoneStart << "\ty: " << yZoneStart << "\tz : " << zZoneStart << endl;
                Porous2D::outf << "->\t介质区长：\t" << zoneLength << "\t介质区宽：" << zoneWidth << endl;
            }
        }
        else
        {
            xZoneStart = x0;
            yZoneStart = y0;
            zZoneStart = z0;
            zoneLength = max(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
            zoneWidth = min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
            if (Porous2D::expressionFaceLength->Value() < Porous2D::expressionFaceWidth->Value())
            {
                changeLenWid = true;
            }
            //----Print process to info window
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t流动形式：外流\n");
                char tempString[256];
                std::sprintf(tempString, "->\t介质区初始点：\tx: %f\ty: %f\tz: %f\n",xZoneStart,yZoneStart,zZoneStart);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t介质区长：\t%f\t介质区宽：\t%f\n",zoneLength,zoneWidth);
                UF_UI_write_listing_window(tempString);
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t流动形式：外流" << endl;
                Porous2D::outf << "->\t介质区初始点：\tx: " << xZoneStart << "\ty: " << yZoneStart << "\tz : " << zZoneStart << endl;
                Porous2D::outf << "->\t介质区长：\t" << zoneLength << "\t介质区宽：\t" << zoneWidth << endl;
            }
        }
        //----Define local parameters
        double ratio = Porous2D::doublePorousRatio->Value();
        double diameter = Porous2D::expressionParticleSize->Value();
        //----Compute colum of particle square
        int numSquare = floor(zoneLength * zoneWidth * (1.0 - ratio) * 4.0 / PI / (diameter * diameter));
        double particleLength = sqrt(PI * diameter * diameter / (4.0 * (1.0 - ratio)));
        int rowSquare = floor(zoneWidth / particleLength);
        int columeSquare = floor(zoneLength / particleLength);
        Porous2D::particleNumber = rowSquare * columeSquare;
        double rowGap = zoneWidth / (double)rowSquare - diameter;
        double columeGap = zoneLength / (double)columeSquare - diameter;
        double rowBoderGap = (zoneWidth - rowSquare * particleLength ) / 2.0;
        double columeBoderGap = (zoneLength - columeSquare * particleLength) / 2.0;
        double realPorosity = (1.0 - Porous2D::particleNumber * PI * diameter * diameter / 4.0 / (zoneLength * zoneWidth)) * 100.0;
        //----Compute start point coordination
        double xStartPoint, yStartPoint, zStartPoint;
        if (changeLenWid)
        {
            xStartPoint = xZoneStart + rowBoderGap + particleLength / 2.0;
            yStartPoint = yZoneStart + columeBoderGap + particleLength / 2.0;
            zStartPoint = zZoneStart;
        }
        else
        {
            xStartPoint = xZoneStart + columeBoderGap + particleLength / 2.0;
            yStartPoint = yZoneStart + rowBoderGap + particleLength / 2.0;
            zStartPoint = zZoneStart;
        }
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            std::sprintf(tempString, "->\t孔隙率：\t%f\t颗粒直径：\t%f\n",ratio,diameter);
            UF_UI_write_listing_window(tempString);
            std::sprintf(tempString, "->\t颗粒数：\t%d\t行间距：\t%f\t列间距：\t%f\n",Porous2D::particleNumber,rowGap,columeGap);
            UF_UI_write_listing_window(tempString);
            std::sprintf(tempString, "->\t行边间隙：\t%f\t列边间隙：\t%f\n",rowBoderGap,columeBoderGap);
            UF_UI_write_listing_window(tempString);
            std::sprintf(tempString, "->\t颗粒中心起始点：\tx: %f\ty: %f\tz: %f\n",xStartPoint,yStartPoint,zStartPoint);
            UF_UI_write_listing_window(tempString);
            std::sprintf(tempString, "->\t实际孔隙率：\t%f\n",realPorosity);
            UF_UI_write_listing_window(tempString);
            UF_UI_write_listing_window("->\t颗粒圆心坐标：\n");
            UF_UI_write_listing_window("->\t[row,colum]\tx\ty\tz\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t孔隙率：\t" << ratio << "\t颗粒直径：\t" << diameter << endl;
            Porous2D::outf << "->\t颗粒数：\t" << Porous2D::particleNumber << "\t行间距：\t" << rowGap << "\t列间距：\t" << columeGap << endl;
            Porous2D::outf << "->\t行边间隙：\t" << rowBoderGap << "\t列边间隙：\t" << columeBoderGap << endl;
            Porous2D::outf << "->\t颗粒中心起始点：\tx: " << xStartPoint << "\ty: " << yStartPoint << "\tz : " << zStartPoint << endl;
            Porous2D::outf << "->\t实际孔隙率：\t" << realPorosity << endl;
            Porous2D::outf << "->\t颗粒圆心坐标:" << endl;
            Porous2D::outf << "->\t[row,colum]\tx\ty\tz" << endl;
        }
        //Generate circle particle curves
        for (int i = 0; i < rowSquare; i++)
        {
            for (int j = 0; j < columeSquare; j++)
            {
                //Initialize AssociativeArcBuiler
                NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                //Get particles' center points 
                //----Create  circle center points
                double x, y, z;
                if (changeLenWid)
                {
                    y = yStartPoint + (particleLength) * j;
                    x = xStartPoint + (particleLength) * i;
                    z = zStartPoint;
                }
                else
                {
                    x = xStartPoint + (particleLength) * j;
                    y = yStartPoint + (particleLength) * i;
                    z = zStartPoint;
                }
                NXOpen::Scalar* scalarX1(NULL);
                scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Scalar* scalarY1(NULL);
                scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Scalar* scalarZ1(NULL);
                scalarZ1 = workPart->Scalars()->CreateScalar(zStartPoint, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                NXOpen::Point* circleCorePoint1;
                circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                Porous2D::centerPointCollector.push_back(circleCorePoint1);
                //Set AssociativeArcBuilder parameters
                //----Create helpPoints for trim section
                Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                Porous2D::helpPointCollector.push_back(helpPoint);
                //----Print center points coordination of cellulose
                if (Porous2D::togglePrintInfo->Value() == true)
                {
                    char tempString[256];
                    std::sprintf(tempString, "->\t[%d,%d]\t%f\t%f\t%f\n",i+1,j+1,x,y,z);
                    UF_UI_write_listing_window(tempString);
                }
                //----Print process to log file
                if (Porous2D::toggleWriteFile->Value() == true)
                {
                    Porous2D::outf << "->\t[" << i + 1 << "," << j + 1 << "]\t" << x << ",\t" << y << ",\t" << z << endl;
                }
                //----Set circle curves' genaration plane
                NXOpen::Vector3d Vector1;
                Vector1 = { 0.0, 0.0, 1.0 };
                //----Open switch to set plane normal direction
                NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                //----Set AssociativeArcBuilder required parameters
                associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionParticleSize->Value());
                associativeArcBuilder1->Limits()->SetFullCircle(true);
                //Create circle particle curves
                NXOpen::NXObject* nXObjectCircle;
                nXObjectCircle = associativeArcBuilder1->Commit();
                //Pass to global parameters
                //----Get particle curves' objects
                Porous2D::particleObject.push_back(nXObjectCircle);
                //----Get particle curves' features
                Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                Porous2D::arcFeatureCollector.push_back(arcFeature);
                //Free memory
                associativeArcBuilder1->Destroy();
            }
        }
        //Print length of arcFeatureCollector and particleObject
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            char tempString[256];
            int arcFeatureNum = Porous2D::arcFeatureCollector.size();
            int parObjectNum = Porous2D::particleObject.size();
            int arcFeatureMax = Porous2D::arcFeatureCollector.max_size();
            int parObjectMax = Porous2D::particleObject.max_size();
            std::sprintf(tempString, "->\tarcFeatureNum:\t%d\tparticleObjectNum:\t%d\n",arcFeatureNum,parObjectNum);
            UF_UI_write_listing_window(tempString);
            std::sprintf(tempString, "->\tarcFeatureCapacity:\t%d\tparticleObjectCapacity:\t%d\n",arcFeatureMax,parObjectMax);
            UF_UI_write_listing_window(tempString);
            UF_UI_write_listing_window("->\t完成中心点与直径成圆！\n");
            UF_UI_write_listing_window("->\t圆线存储...\n");
            UF_UI_write_listing_window("->\t内存释放！\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            int arcFeatureNum = Porous2D::arcFeatureCollector.size();
            int parObjectNum = Porous2D::particleObject.size();
            int arcFeatureMax = Porous2D::arcFeatureCollector.max_size();
            int parObjectMax = Porous2D::particleObject.max_size();
            Porous2D::outf << "->\tarcFeatureNum:\t" << arcFeatureNum << "\tparticleObjectNum:" << parObjectNum << endl;
            Porous2D::outf << "->\tarcFeatureCapacity:\t" << arcFeatureMax << "\tparticleObjectCapacity:" << parObjectMax << endl;
            Porous2D::outf << "->\t完成中心点与直径成圆！" << endl;
            Porous2D::outf << "->\t圆线存储..." << endl;
            Porous2D::outf << "->\t内存释放！" << endl;
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
    {

    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
    {

    }
}

//Generate hexagon form porous
void Porous2D::GenHexagon(NXOpen::Part* workPart)
{
    //Judge particle shape
    if ((std::string)(Porous2D::enumParticleShape->ValueAsString()).GetText() == "Circle")
    {
        //----Print process to info window
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t生成颗粒：六边形阵列\n");
            UF_UI_write_listing_window("->\t开始生成颗粒...\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t生成颗粒：六边形阵列" << endl;
            Porous2D::outf << "->\t开始生成颗粒..." << endl;
        }
        //Judge generation method
        if (Porous2D::togglePaper->Value() == true)
        {
            //----Print process to info window
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t------------------纸幅专用生成方式------------------\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t------------------纸幅专用生成方式------------------" << endl;
            }
            //----Set compress ratio
            double comRatio = Porous2D::expressionComRatio->Value();
            //----Get sheet start point's coordinate
            NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
            double x0 = setPoint1->Coordinates().X;
            double y0 = setPoint1->Coordinates().Y;
            double z0 = setPoint1->Coordinates().Z;
            //----Get sheet height
            if (Porous2D::sheetWidth == 0)
            {
                Porous2D::sheetWidth = Porous2D::expressionBasisWeight->Value() /1000.0 * Porous2D::expressionDryContentFinal->Value() / 100.0\
                    / (1.0 - Porous2D::doublePorousRatio->Value()) * (1.0 / 1.5e3 + (1.0 - Porous2D::expressionDryContentNow->Value() / 100.0) \
                        / (Porous2D::expressionDryContentNow->Value() / 100.0) / 1e3) * 1000.0;
                Porous2D::sheetLength = Porous2D::sheetWidth * Porous2D::expressionLenWidRatio->Value();
            }
            //----Get sheet center point's coordinate
            double xSheetCenter = setPoint1->Coordinates().X + Porous2D::sheetLength / 2.0;
            double ySheetCenter = setPoint1->Coordinates().Y + Porous2D::sheetWidth * comRatio / 2.0;
            double zSheetCenter = setPoint1->Coordinates().Z;
            //----Get porous zone boundary start point coordinary
            NXOpen::Point* pointPorousZoneStart;
            double xZoneStart = xSheetCenter - Porous2D::sheetLength / 2.0;
            double yZoneStart = ySheetCenter - Porous2D::sheetWidth * comRatio / 2.0;
            double zZoneStart = zSheetCenter;
            double zoneLength = Porous2D::sheetLength;
            double zoneWidth = Porous2D::sheetWidth * comRatio;
            //----Define local parameters
            double ratio = Porous2D::doublePorousRatio->Value();
            double diameter = Porous2D::expressionCelDiameter->Value();
            //----Compute colum of particle hexagon
            double gap = sqrt(PI / 2.0 / sqrt(3.0) / (1.0 -ratio)) * diameter;
            int rowHexagon = floor(Porous2D::sheetWidth / (sqrt(3.0) / 2.0 * gap));
            int columHexagon = floor(zoneLength / gap);
            Porous2D::particleNumber = rowHexagon * columHexagon;
            double rowBoderGap = (zoneLength - gap * (columHexagon + 0.5)) / 2.0;
            double colBoderGap = (Porous2D::sheetWidth - rowHexagon * gap * sqrt(3.0) / 2.0)  * comRatio / 2.0;
            double origPorosity = (1.0 - Porous2D::particleNumber * PI * diameter * diameter / 4.0 / (zoneLength * Porous2D::sheetWidth)) * 100.0;
            double realPorosity = (1.0 - Porous2D::particleNumber * PI * diameter * diameter / 4.0 / (zoneLength * zoneWidth)) * 100.0;
            //----Check compress ratio 
            double minComRatio = (4.0 * diameter * diameter - gap * gap) / (3.0 * gap * gap);
            if (comRatio < minComRatio)
            {
                char msg[256];
                sprintf(msg, "!!!Error: Compressor ratio is too small!");
                uc1601(msg,1);
                if (Porous2D::togglePrintInfo->Value() == true)
                {
                    UF_UI_write_listing_window("->!!!Error: Compressor ratio is too small!");
                }
                if (Porous2D::toggleWriteFile->Value() == true)
                {
                    Porous2D::outf << "->!!!Error: Compressor ratio is too small!" << endl;
                }
            }
            //----Compute start point coordination
            double xStartPoint = xZoneStart + rowBoderGap + gap / 2.0;
            double yStartPoint = yZoneStart + colBoderGap + gap  * comRatio * sqrt(3.0) / 4.0;
            double zStartPoint = zZoneStart;
            //----Print process to info window
            char tempString[256];
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t纸幅基本信息：\n");
                std::sprintf(tempString, "->\t纸幅基重:%f (g/m2)\n", Porous2D::expressionBasisWeight->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t成纸干度:%f (%%)\n", Porous2D::expressionDryContentFinal->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t当前干度:%f (%%)\n", Porous2D::expressionDryContentNow->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纸幅厚度:%f (mm)\n", Porous2D::sheetWidth);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纤维直径:%f (mm)\n", Porous2D::expressionCelDiameter->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纤维长度:%f (mm)\n", Porous2D::expressionCelLength->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纤维长度密度:%f (g/m)\n", Porous2D::expressionLenDensity->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t行数:%d\t纤维行间距:%f (mm)\n", rowHexagon, sqrt(3.0)/2.0*gap * comRatio);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t列数:%d\t纤维列间距:%f (mm)\n", columHexagon, gap);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t纤维数量：%d\n", Porous2D::particleNumber);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t设计孔隙率:%f (%%)\n", ratio * 100.0);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t压缩前孔隙率:%f (%%)\n", origPorosity);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t压缩系数:%f\n", comRatio);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t实际孔隙率:%f (%%)\n", realPorosity);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t最小压缩系数:%f\n", minComRatio);
                UF_UI_write_listing_window(tempString);
                UF_UI_write_listing_window("->\t纤维圆心坐标：\n");
                UF_UI_write_listing_window("->\t[row,colum]\tx\ty\tz\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t纸幅基本信息：\n" << "->\t纸幅基重:" << Porous2D::expressionDryContentFinal->Value() << " (%)" << endl;
                Porous2D::outf << "->\t成纸干度:" << Porous2D::expressionDryContentFinal->Value() << " (%)" << endl;
                Porous2D::outf << "->\t当前干度:" << Porous2D::expressionDryContentNow->Value() << " (%)" << endl;
                Porous2D::outf << "->\t纸幅厚度:" << Porous2D::sheetWidth << " (mm)" << endl;
                Porous2D::outf << "->\t纤维直径:" << Porous2D::expressionCelDiameter->Value() << " (mm)" << endl;
                Porous2D::outf << "->\t纤维长度:" << Porous2D::expressionCelLength->Value() << " (mm)" << endl;
                Porous2D::outf << "->\t纤维长度密度:" << Porous2D::expressionLenDensity->Value() << " (g/m)" << endl;
                Porous2D::outf << "->\t行数:" << rowHexagon << "\t纤维行间距: " << sqrt(3.0)/2.0*gap*comRatio << " (mm)" << endl;
                Porous2D::outf << "->\t列数:" << columHexagon << "\t纤维列间距: " << gap << " (mm)" << endl;
                Porous2D::outf << "->\t纤维数量:" << Porous2D::particleNumber << endl;
                Porous2D::outf << "->\t设计孔隙率:" << ratio * 100.0 << " (%)" << endl;
                Porous2D::outf << "->\t压缩前孔隙率:" << origPorosity << " (%)" << endl;
                Porous2D::outf << "->\t压缩系数:" << comRatio <<  endl;
                Porous2D::outf << "->\t实际孔隙率:" << realPorosity << " (%)" << endl;
                Porous2D::outf << "->\t最小压缩系数:" << minComRatio <<  endl;
                Porous2D::outf << "->\t纤维圆心坐标:" << endl;
                Porous2D::outf << "->\t[row,colum]\tx\ty\tz" << endl;
            }
            for (int i = 0; i < rowHexagon; i++)
            {
                for (int j = 0; j < columHexagon; j++)
                {
                    //Initialize AssociativeArcBuiler
                    NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                    NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                    associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                    //Get particles' center points 
                    //----Create  circle center points
                    double x = xStartPoint + (gap / 2.0) * abs(sin((double)i / 2.0 * PI)) + gap * j;
                    double y = yStartPoint + sqrt(3.0) * gap * comRatio / 2.0 * i;
                    double z = zStartPoint;
                    NXOpen::Scalar* scalarX1(NULL);
                    scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarY1(NULL);
                    scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarZ1(NULL);
                    scalarZ1 = workPart->Scalars()->CreateScalar(z, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Point* circleCorePoint1;
                    circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    Porous2D::centerPointCollector.push_back(circleCorePoint1);
                    //----Print center points coordination of cellulose
                    if (Porous2D::togglePrintInfo->Value() == true)
                    {
                        std::sprintf(tempString, "->\t[%d,%d]\t%f\t%f\t%f\n",i+1,j+1,x,y,z);
                        UF_UI_write_listing_window(tempString);
                    }
                    //----Print process to log file
                    if (Porous2D::toggleWriteFile->Value() == true)
                    {
                        Porous2D::outf << "->\t[" << i + 1 << "," << j + 1 << "]\t" << x << ",\t" << y << ",\t" << z << endl;
                    }
                    //Set AssociativeArcBuilder parameters
                    //----Create helpPoints for trim section
                    Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                    Porous2D::helpPointCollector.push_back(helpPoint);
                    //----Set circle curves' genaration plane
                    NXOpen::Vector3d Vector1;
                    Vector1 = { 0.0, 0.0, 1.0 };
                    //----Open switch to set plane normal direction
                    NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                    planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                    associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                    //----Set AssociativeArcBuilder required parameters
                    associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                    associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                    associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                    associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                    associativeArcBuilder1->Diameter()->SetValue(Porous2D::expressionCelDiameter->Value());
                    associativeArcBuilder1->Limits()->SetFullCircle(true);
                    //Create circle particle curves
                    NXOpen::NXObject* nXObjectCircle;
                    nXObjectCircle = associativeArcBuilder1->Commit();
                    //Pass to global parameters
                    //----Get particle curves' objects
                    Porous2D::particleObject.push_back(nXObjectCircle);
                    //----Get particle curves' features
                    Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                    Porous2D::arcFeatureCollector.push_back(arcFeature);
                    //Free memory
                    associativeArcBuilder1->Destroy();
                }
            }
            //Print length of arcFeatureCollector and particleObject
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                int arcFeatureNum = Porous2D::arcFeatureCollector.size();
                int parObjectNum = Porous2D::particleObject.size();
                int arcFeatureMax = Porous2D::arcFeatureCollector.max_size();
                int parObjectMax = Porous2D::particleObject.max_size();
                int arcFeatureCap = Porous2D::arcFeatureCollector.capacity();
                int parObjectCap = Porous2D::particleObject.capacity();
                std::sprintf(tempString, "->\tarcFeatureNum:\t%d\tparticleObjectNum:\t%d\n",arcFeatureNum,parObjectNum);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\tarcFeatureMax:\t%d\tparticleObjectMax:\t%d\n",arcFeatureMax,parObjectMax);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\tarcFeatureCap:\t%d\tparticleObjectCap:\t%d\n",arcFeatureCap,parObjectCap);
                UF_UI_write_listing_window(tempString);
                UF_UI_write_listing_window("->\t完成中心点与直径成圆！\n");
                UF_UI_write_listing_window("->\t圆线存储...\n");
                UF_UI_write_listing_window("->\t内存释放！\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                int arcFeatureNum = Porous2D::arcFeatureCollector.size();
                int parObjectNum = Porous2D::particleObject.size();
                int arcFeatureMax = Porous2D::arcFeatureCollector.max_size();
                int parObjectMax = Porous2D::particleObject.max_size();
                int arcFeatureCap = Porous2D::arcFeatureCollector.capacity();
                int parObjectCap = Porous2D::particleObject.capacity();
                Porous2D::outf << "->\tarcFeatureNum:\t" << arcFeatureNum << "\tparticleObjectNum:" << parObjectNum << endl;
                Porous2D::outf << "->\tarcFeatureMax:\t" << arcFeatureMax << "\tparticleObjectCapacity:" << parObjectMax << endl;
                Porous2D::outf << "->\tarcFeatureCap:\t" << arcFeatureCap << "\tparticleObjectCapacity:" << parObjectCap << endl;
                Porous2D::outf << "->\t完成中心点与直径成圆！" << endl;
                Porous2D::outf << "->\t圆线存储..." << endl;
                Porous2D::outf << "->\t内存释放！" << endl;
            }
        }
        else
        {
            //----Print process to info window
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t------------------普通介质生成方式------------------\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t------------------普通介质生成方式------------------" << endl;
            }
            //----Set compress ratio
            double comRatio = Porous2D::expressionComRatio->Value();
            //----Get sheet start point's coordinate
            NXOpen::Point* setPoint1 = workPart->Points()->CreatePoint(Porous2D::pointSheetStart->Point());
            double x0 = setPoint1->Coordinates().X;
            double y0 = setPoint1->Coordinates().Y;
            double z0 = setPoint1->Coordinates().Z;
            //----Get sheet center point's coordinate
            double xSheetCenter = setPoint1->Coordinates().X + Porous2D::expressionFaceLength->Value() / 2.0;
            double ySheetCenter = setPoint1->Coordinates().Y + Porous2D::expressionFaceWidth->Value() / 2.0;
            double zSheetCenter = setPoint1->Coordinates().Z;
            //----Get porous zone boundary start point coordinary
            NXOpen::Point* pointPorousZoneStart;
            double xZoneStart, yZoneStart, zZoneStart;
            double zoneLength, zoneWidth;
            bool changeLenWid = false;
            bool outFluid = false;
            //Judge hexagon direction
            double xStartPoint, yStartPoint, zStartPoint;
            if (Porous2D::toggleOutFluid->Value() == false)
            {
                xZoneStart = xSheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
                yZoneStart = ySheetCenter - min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value()) / 2.0;
                zZoneStart = zSheetCenter;
                zoneLength = min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
                if (Porous2D::expressionFaceLength->Value() < Porous2D::expressionFaceWidth->Value())
                {
                    changeLenWid = true;
                }
                zoneWidth = zoneLength;
                //----Print process to info window
                if (Porous2D::togglePrintInfo->Value() == true)
                {
                    UF_UI_write_listing_window("->\t流动形式：内流\n");
                    char tempString[256];
                    std::sprintf(tempString, "->\t介质区初始点：\tx: %f\ty: %f\tz: %f\n",xZoneStart,yZoneStart,zZoneStart);
                    UF_UI_write_listing_window(tempString);
                    std::sprintf(tempString, "->\t介质区长：\t%f\t介质区宽：\t%f\n",zoneLength,zoneWidth);
                    UF_UI_write_listing_window(tempString);
                }
                //----Print process to log file
                if (Porous2D::toggleWriteFile->Value() == true)
                {
                    Porous2D::outf << "->\t流动形式：内流" << endl;
                    Porous2D::outf << "->\t介质区初始点：\tx: " << xZoneStart << "\ty: " << yZoneStart << "\tz : " << zZoneStart << endl;
                    Porous2D::outf << "->\t介质区长：\t" << zoneLength << "\t介质区宽：" << zoneWidth << endl;
                }
            }
            else
            {
                outFluid = true;
                xZoneStart = x0;
                yZoneStart = y0;
                zZoneStart = z0;
                zoneLength = max(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
                Porous2D::sheetWidth = min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
                zoneWidth = comRatio * min(Porous2D::expressionFaceLength->Value(), Porous2D::expressionFaceWidth->Value());
                if (Porous2D::expressionFaceLength->Value() < Porous2D::expressionFaceWidth->Value())
                {
                    changeLenWid = true;
                }
                //----Print process to info window
                if (Porous2D::togglePrintInfo->Value() == true)                             
                {
                    UF_UI_write_listing_window("->\t流动形式：外流\n");
                    char tempString[256];
                    std::sprintf(tempString, "->\t介质区初始点：\tx: %f\ty: %f\tz: %f\n",xZoneStart,yZoneStart,zZoneStart);
                    UF_UI_write_listing_window(tempString);
                    std::sprintf(tempString, "->\t介质区长：\t%f\t介质区宽：\t%f\n",zoneLength,zoneWidth);
                    UF_UI_write_listing_window(tempString);
                }
                //----Print process to log file
                if (Porous2D::toggleWriteFile->Value() == true)
                {
                    Porous2D::outf << "->\t流动形式：外流" << endl;
                    Porous2D::outf << "->\t介质区初始点：\tx: " << xZoneStart << "\ty: " << yZoneStart << "\tz : " << zZoneStart << endl;
                    Porous2D::outf << "->\t介质区长：\t" << zoneLength << "\t介质区宽：\t" << zoneWidth << endl;
                }
            }
            //----Define local parameters
            double ratio = Porous2D::doublePorousRatio->Value();
            double diameter = Porous2D::expressionParticleSize->Value();
            Porous2D::particleDiameter = diameter;
            //----Compute colum of particle hexagon
            double gap = sqrt(PI / 2.0 / sqrt(3.0) / (1.0 -ratio)) * diameter;
            int rowHexagon = floor(zoneWidth / (sqrt(3.0) / 2.0 * gap));
            int columeHexagon = floor(zoneLength / gap);
            Porous2D::particleNumber = rowHexagon * columeHexagon;
            double rowBoderGap = (zoneLength - gap * (columeHexagon + 0.5)) / 2.0;
            double colBoderGap = (zoneWidth - rowHexagon * gap * sqrt(3.0) / 2.0) / 2.0;
            double realPorosity = (1.0 - Porous2D::particleNumber * PI * diameter * diameter / 4.0 / (zoneLength * zoneWidth)) * 100.0;
            //----Compute start point coordination
            if (changeLenWid)
            {
                //Compute start point coordination
                if (outFluid)
                {
                    xStartPoint = xZoneStart + colBoderGap + gap * sqrt(3.0) / 4.0;
                    yStartPoint = yZoneStart + rowBoderGap + gap / 2.0;
                    zStartPoint = zZoneStart;
                }
                else
                {
                    xStartPoint = xZoneStart + rowBoderGap + gap / 2.0;
                    yStartPoint = yZoneStart + colBoderGap + gap * sqrt(3.0) / 4.0;
                    zStartPoint = zZoneStart;
                }
            }
            else
            {
                //Compute start point coordination
                if (outFluid)
                {
                    xStartPoint = xZoneStart + rowBoderGap + gap / 2.0;
                    yStartPoint = yZoneStart + colBoderGap + gap * sqrt(3.0) / 4.0;
                    zStartPoint = zZoneStart;
                }
                else
                {
                    xStartPoint = xZoneStart + colBoderGap + gap * sqrt(3.0) / 4.0;
                    yStartPoint = yZoneStart + rowBoderGap + gap / 2.0;
                    zStartPoint = zZoneStart;
                }
            }
            //----Print process to info window
            char tempString[256];
            if (Porous2D::togglePrintInfo->Value() == true)
            {
                UF_UI_write_listing_window("->\t介质基本信息：\n");
                std::sprintf(tempString, "->\t介质长度：%f (mm)\n", Porous2D::expressionFaceLength->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t介质宽度：%f (mm)\n", Porous2D::expressionFaceWidth->Value());
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t设计孔隙率：%f (%%)\n", ratio * 100.0);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t实际孔隙率：%f (%%)\n", realPorosity);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t行数：%d\t纤维行间距：%f (mm)\n", rowHexagon, sqrt(3.0)/2.0*gap);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t列数：%d\t纤维列间距：%f (mm)\n", rowHexagon, gap);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\t颗粒数量：%d\t颗粒直径：%f\n", Porous2D::particleNumber, diameter);
                UF_UI_write_listing_window(tempString);
                UF_UI_write_listing_window("->\t颗粒圆心坐标：\n");
                UF_UI_write_listing_window("->\t[row,colum]\tx\ty\tz\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                Porous2D::outf << "->\t介质基本信息：\n" << "->\t介质长度:" << Porous2D::expressionFaceLength->Value() << " (mm)" << endl;
                Porous2D::outf << "->\t介质宽度:" << Porous2D::expressionFaceWidth->Value() << " (mm)" << endl;
                Porous2D::outf << "->\t设计孔隙率:" << ratio * 100.0 << " (%)" << endl;
                Porous2D::outf << "->\t实际孔隙率:" << realPorosity << " (%)" << endl;
                Porous2D::outf << "->\t行数:" << rowHexagon << "\t颗粒行间距: " << sqrt(3.0)/2.0*gap << " (mm)" << endl;
                Porous2D::outf << "->\t列数:" << rowHexagon << "\t颗粒列间距: " << gap << " (mm)" << endl;
                Porous2D::outf << "->\t颗粒数量:" << Porous2D::particleNumber << "\t颗粒直径：" << diameter << endl;
                Porous2D::outf << "->\t颗粒圆心坐标:" << endl;
                Porous2D::outf << "->\t[row,colum]\tx\ty\tz" << endl;
            }
            //Generate circle particle curves
            for (int i = 0; i < rowHexagon; i++)
            {
                for (int j = 0; j < columeHexagon; j++)
                {
                    //Initialize AssociativeArcBuiler
                    NXOpen::Features::AssociativeArc* nullNXOpen_Features_AssociativeArc(NULL);
                    NXOpen::Features::AssociativeArcBuilder* associativeArcBuilder1;
                    associativeArcBuilder1 = workPart->BaseFeatures()->CreateAssociativeArcBuilder(nullNXOpen_Features_AssociativeArc);
                    //Get particles' center points 
                    //----Create  circle center points
                    double x, y, z;
                    if (changeLenWid)
                    {
                        if (outFluid)
                        {
                            y = yStartPoint + (gap / 2.0) * abs(sin((double)i / 2.0 * PI)) + gap * j;
                            x = xStartPoint + sqrt(3.0) * gap / 2.0 * i;
                            z = zStartPoint;
                        }
                        else
                        {
                            x = xStartPoint + (gap / 2.0) * abs(sin((double)i / 2.0 * PI)) + gap * j;
                            y = yStartPoint + sqrt(3.0) * gap / 2.0 * i;
                            z = zStartPoint;
                        }
                    }
                    else
                    {
                        if (outFluid)
                        {
                            x = xStartPoint + (gap / 2.0) * abs(sin((double)i / 2.0 * PI)) + gap * j;
                            y = yStartPoint + sqrt(3.0) * gap / 2.0 * i;
                            z = zStartPoint;
                        }
                        else
                        {
                            y = yStartPoint + (gap / 2.0) * abs(sin((double)i / 2.0 * PI)) + gap * j;
                            x = xStartPoint + sqrt(3.0) * gap / 2.0 * i;
                            z = zStartPoint;
                        }
                    }

                    NXOpen::Scalar* scalarX1(NULL);
                    scalarX1 = workPart->Scalars()->CreateScalar(x, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarY1(NULL);
                    scalarY1 = workPart->Scalars()->CreateScalar(y, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Scalar* scalarZ1(NULL);
                    scalarZ1 = workPart->Scalars()->CreateScalar(z, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    NXOpen::Point* circleCorePoint1;
                    circleCorePoint1 = workPart->Points()->CreatePoint(scalarX1, scalarY1, scalarZ1, NXOpen::SmartObject::UpdateOptionWithinModeling);
                    Porous2D::centerPointCollector.push_back(circleCorePoint1);
                    //----Print center points coordination of cellulose
                    if (Porous2D::togglePrintInfo->Value() == true)
                    {
                        std::sprintf(tempString, "->\t[%d,%d]\t%f\t%f\t%f\n",i+1,j+1,x,y,z);
                        UF_UI_write_listing_window(tempString);
                    }
                    //----Print process to log file
                    if (Porous2D::toggleWriteFile->Value() == true)
                    {
                        Porous2D::outf << "->\t[" << i + 1 << "," << j + 1 << "]\t" << x << ",\t" << y << ",\t" << z << endl;
                    }
                    //Set AssociativeArcBuilder parameters
                    //----Create helpPoints for trim section
                    Porous2D::helpPoint = { circleCorePoint1->Coordinates().X + diameter / 2.0 , circleCorePoint1->Coordinates().Y, circleCorePoint1->Coordinates().Z };
                    Porous2D::helpPointCollector.push_back(helpPoint);
                    //----Set circle curves' genaration plane
                    NXOpen::Vector3d Vector1;
                    Vector1 = { 0.0, 0.0, 1.0 };
                    //----Open switch to set plane normal direction
                    NXOpen::GeometricUtilities::SupportPlaneData* planeData(associativeArcBuilder1->SupportPlaneData());
                    planeData->SetSupportPlaneLockStatus(NXOpen::GeometricUtilities::SupportPlaneData::LockPlaneStatus::LockPlaneStatusCenterPointDirection);
                    associativeArcBuilder1->SetCenterRadiusLockedPlaneDirection(Vector1);
                    //----Set AssociativeArcBuilder required parameters
                    associativeArcBuilder1->SetStartPointOptions(NXOpen::Features::AssociativeArcBuilder::StartOption::StartOptionPoint);
                    associativeArcBuilder1->SetEndPointOptions(NXOpen::Features::AssociativeArcBuilder::EndOption::EndOptionDiameter);
                    associativeArcBuilder1->SetType(NXOpen::Features::AssociativeArcBuilder::TypesArcFromCenter);
                    associativeArcBuilder1->CenterPoint()->SetValue(circleCorePoint1);
                    associativeArcBuilder1->Diameter()->SetValue(Porous2D::particleDiameter);
                    associativeArcBuilder1->Limits()->SetFullCircle(true);
                    //Create circle particle curves
                    NXOpen::NXObject* nXObjectCircle;
                    nXObjectCircle = associativeArcBuilder1->Commit();
                    //Pass to global parameters
                    //----Get particle curves' objects
                    Porous2D::particleObject.push_back(nXObjectCircle);
                    //----Get particle curves' features
                    Porous2D::arcFeature = dynamic_cast<NXOpen::Features::AssociativeArc*>(nXObjectCircle);
                    Porous2D::arcFeatureCollector.push_back(arcFeature);
                    //Free memory
                    associativeArcBuilder1->Destroy();
                }
            }
            //Print length of arcFeatureCollector and particleObject
            if (Porous2D::togglePrintInfo->Value() == true)
            {
//                char tempString[256];
                int arcFeatureNum = Porous2D::arcFeatureCollector.size();
                int parObjectNum = Porous2D::particleObject.size();
                int arcFeatureMax = Porous2D::arcFeatureCollector.max_size();
                int parObjectMax = Porous2D::particleObject.max_size();
                int arcFeatureCap = Porous2D::arcFeatureCollector.capacity();
                int parObjectCap = Porous2D::particleObject.capacity();
                std::sprintf(tempString, "->\tarcFeatureNum:\t%d\tparticleObjectNum:\t%d\n",arcFeatureNum,parObjectNum);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\tarcFeatureMax:\t%d\tparticleObjectMax:\t%d\n",arcFeatureMax,parObjectMax);
                UF_UI_write_listing_window(tempString);
                std::sprintf(tempString, "->\tarcFeatureCap:\t%d\tparticleObjectCap:\t%d\n",arcFeatureCap,parObjectCap);
                UF_UI_write_listing_window(tempString);
                UF_UI_write_listing_window("->\t完成中心点与直径成圆！\n");
                UF_UI_write_listing_window("->\t圆线存储...\n");
                UF_UI_write_listing_window("->\t内存释放！\n");
            }
            //----Print process to log file
            if (Porous2D::toggleWriteFile->Value() == true)
            {
                int arcFeatureNum = Porous2D::arcFeatureCollector.size();
                int parObjectNum = Porous2D::particleObject.size();
                int arcFeatureMax = Porous2D::arcFeatureCollector.max_size();
                int parObjectMax = Porous2D::particleObject.max_size();
                int arcFeatureCap = Porous2D::arcFeatureCollector.capacity();
                int parObjectCap = Porous2D::particleObject.capacity();
                Porous2D::outf << "->\tarcFeatureNum:\t" << arcFeatureNum << "\tparticleObjectNum:" << parObjectNum << endl;
                Porous2D::outf << "->\tarcFeatureMax:\t" << arcFeatureMax << "\tparticleObjectCapacity:" << parObjectMax << endl;
                Porous2D::outf << "->\tarcFeatureCap:\t" << arcFeatureCap << "\tparticleObjectCap:" << parObjectCap << endl;
                Porous2D::outf << "->\t完成中心点与直径成圆！" << endl;
                Porous2D::outf << "->\t圆线存储..." << endl;
                Porous2D::outf << "->\t内存释放！" << endl;
            }
        }
    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Square")
    {

    }
    else if ((std::string)(enumParticleShape->ValueAsString()).GetText() == "Triangle")
    {

    }
}

//Save 3D porous media and export as IGES files
void Porous2D::SaveAsIGES(NXOpen::Part* workPart)
{
    //Print length of arcFeatureCollector and particleObject
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->文件保存：\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->文件保存：" << endl;
    }
    string workPath = workPart->FullPath().GetLocaleText();
    string workName = workPart->Name().GetLocaleText();
    int namePosition = workPath.rfind(workName);
    stringstream ssNamePosition;
    ssNamePosition << namePosition;
    string filePath = workPath.substr(0, namePosition);
    stringstream ssNewWorkName, ssNewWorkPath;
    if (Porous2D::togglePaper->Value() == true)
    {
        ssNewWorkName
            << Porous2D::expressionBasisWeight->Value() << "g_m^2-" \
            << Porous2D::expressionDryContentFinal->Value() << "%-" \
            << Porous2D::expressionDryContentNow->Value() << "%-" \
            << Porous2D::expressionLenDensity->Value() << "g_m-" \
            << Porous2D::expressionCelDiameter->Value() << "m-" \
            << Porous2D::expressionLenWidRatio->Value() << "ext-" \
            << Porous2D::expressionComRatio->Value() << "comp-" \
            << Porous2D::doublePorousRatio->Value() * 100.0 << "%porosity";
        ssNewWorkPath << filePath << ssNewWorkName.str() << ".prt";
    }
    else
    {
        ssNewWorkName
            << (std::string)(Porous2D::enumGenMethod->ValueAsString()).GetText() << "-" \
            << Porous2D::expressionFaceLength->Value() << "mm-" \
            << Porous2D::expressionFaceWidth->Value() << "mm-" \
            << Porous2D::expressionParticleSize->Value() << "mm-" \
            << Porous2D::expressionComRatio->Value() << "comp-" \
            << Porous2D::doublePorousRatio->Value() * 100.0 << "%porosity";
        ssNewWorkPath << filePath << ssNewWorkName.str() << ".prt";
    }
    //Print length of arcFeatureCollector and particleObject
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t文件工作路径：\n");
        UF_UI_write_listing_window(filePath.c_str());
        UF_UI_write_listing_window("\n");
        UF_UI_write_listing_window("->\t当前文件名：\n");
        UF_UI_write_listing_window(workName.c_str());
        UF_UI_write_listing_window("\n");
        UF_UI_write_listing_window("->\t保存为：\n");
        UF_UI_write_listing_window(ssNewWorkPath.str().c_str());
        UF_UI_write_listing_window("\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t文件工作路径：" << endl;
        Porous2D::outf << filePath << endl;
        Porous2D::outf << "->\t当前文件名：" << endl;
        Porous2D::outf << workName << endl;
        Porous2D::outf << "->\t保存为：" << endl;
        Porous2D::outf << ssNewWorkPath.str() << endl;
    }
    //Print length of arcFeatureCollector and particleObject
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t保存中...\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t保存中..." << endl;
    }
    bool fileExistJudge;
    struct stat buffer;
    fileExistJudge = stat(ssNewWorkPath.str().c_str(), &buffer) == 0;
    bool msgShow = false;
    if (fileExistJudge)
    {
        //Print length of arcFeatureCollector and particleObject
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t文件已存在，请手动保存！\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t文件已存在，请手动保存！" << endl;
        }
        msgShow = true;
    }
    else
    {
        workPart->AssignPermanentName(ssNewWorkPath.str().c_str());
        NXOpen::PartSaveStatus *partSaveStatus1;
        partSaveStatus1 = workPart->Save(NXOpen::BasePart::SaveComponentsTrue, NXOpen::BasePart::CloseAfterSaveFalse);
        //Print length of arcFeatureCollector and particleObject
        if (Porous2D::togglePrintInfo->Value() == true)
        {
            UF_UI_write_listing_window("->\t保存完成！\n");
            UF_UI_write_listing_window("->\t内存释放！\n");
        }
        //----Print process to log file
        if (Porous2D::toggleWriteFile->Value() == true)
        {
            Porous2D::outf << "->\t保存完成！" << endl;
            Porous2D::outf << "->\t内存释放！\n" << endl;
        }
        delete partSaveStatus1;
    }
    //Print length of arcFeatureCollector and particleObject
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->导出IGES：\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->导出IGES：\n" << endl;
    }
    //Export to IGES files
    NXOpen::IgesCreator *igesCreator1;
    igesCreator1 = theSession->DexManager()->CreateIgesCreator();
    igesCreator1->SetExportModelData(true);
    igesCreator1->SetExportDrawings(true);
    igesCreator1->SetMapTabCylToBSurf(true);
    igesCreator1->SetBcurveTol(0.050799999999999998);
    igesCreator1->SetIdenticalPointResolution(0.001);
    igesCreator1->SetMaxThreeDMdlSpace(10000.0);
    igesCreator1->ObjectTypes()->SetCurves(true);
    igesCreator1->ObjectTypes()->SetSurfaces(true);
    igesCreator1->ObjectTypes()->SetAnnotations(true);
    igesCreator1->ObjectTypes()->SetStructures(true);
    igesCreator1->ObjectTypes()->SetSolids(true);
//    igesCreator1->SetSettingsFile("D:\\Program Files\\Siemens\\NX1899\\iges\\igesexport.def");
    igesCreator1->SetExportDrawings(false);
    igesCreator1->ExportSelectionBlock()->SetSelectionScope(NXOpen::ObjectSelector::ScopeSelectedObjects);
    igesCreator1->ObjectTypes()->SetCurves(false);
    igesCreator1->ObjectTypes()->SetSurfaces(false);
    igesCreator1->ObjectTypes()->SetAnnotations(false);
    igesCreator1->ObjectTypes()->SetStructures(false);
    igesCreator1->SetMapRevolvedFacesTo(NXOpen::IgesCreator::MapRevolvedFacesOptionBSurfaces);
    igesCreator1->SetMapCrossHatchTo(NXOpen::IgesCreator::CrossHatchMapEnumSectionArea);
    igesCreator1->SetBcurveTol(0.050799999999999998);
    igesCreator1->SetInputFile(ssNewWorkPath.str());
    //----Find Journalldentifier of thicken sheet body
    NXOpen::NXString thickenSheetID = Porous2D::thickenSheetObject->JournalIdentifier();
    NXOpen::Body *body1(dynamic_cast<NXOpen::Body *>(workPart->Bodies()->FindObject(thickenSheetID)));
    bool added1;
    added1 = igesCreator1->ExportSelectionBlock()->SelectionComp()->Add(body1);
    //----Set output file path
    stringstream ssIgesPath;
    ssIgesPath << filePath << ssNewWorkName.str() << ".igs";
    igesCreator1->SetOutputFile(ssIgesPath.str());
    igesCreator1->SetFileSaveFlag(false);
    igesCreator1->SetLayerMask("1-256");
    igesCreator1->SetDrawingList("");
    igesCreator1->SetViewList("Top,Front,Right,Back,Bottom,Left,Isometric,Trimetric,User Defined");
    igesCreator1->SetProcessHoldFlag(true);
    NXOpen::NXObject *nXObject1;
    //Print length of arcFeatureCollector and particleObject
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t导出中...\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t导出中..." << endl;
    }
    nXObject1 = igesCreator1->Commit();
    //Print length of arcFeatureCollector and particleObject
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t导出完成！\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t导出完成！" << endl;
    }
    igesCreator1->Destroy();
    //Print length of arcFeatureCollector and particleObject
    if (Porous2D::togglePrintInfo->Value() == true)
    {
        UF_UI_write_listing_window("->\t内存释放！\n");
    }
    //----Print process to log file
    if (Porous2D::toggleWriteFile->Value() == true)
    {
        Porous2D::outf << "->\t内存释放！\n" << endl;
    }
    if (msgShow)
    {
        uc1601("文件已存在，请手动保存！",1);
    }
}

bool sitesOrdered(const Point2& s1, const Point2& s2)
{
    if (s1.y < s2.y)
    {
        return true;
    }
    else if (s1.y == s2.y && s1.x < s2.x)
    {
        return true;
    }
    else
    {
        return false;
    }
}

//class compare 
//{
//public:
//    double vertxMinX;
//    double vertxMinY;
//    std::vector<Point2> sortVtx1;
//    void orderVertxPoints(std::vector<Point2>& vertxPoints);
//    bool vertxOrdered(const Point2& s1, const Point2& s2);
//};

static double vertxMinX;
static double vertxMinY;

static bool vertxOrdered(const Point2 & s1, const Point2 & s2)
{
    double dx1 = s1.x - vertxMinX;
    double dy1 = s1.y - vertxMinY;
    double dx2 = s2.x - vertxMinX;
    double dy2 = s2.y - vertxMinY;
    double sModule1 = sqrt(dx1 * dx1 + dy1 * dy1);
    double sModule2 = sqrt(dx2 * dx2 + dy2 * dy2);
    double thelta1 = acos(dx1 / sModule1);
    double thelta2 = acos(dx2 / sModule2);
    if (thelta1 < thelta2)
    {
        return true;
    }
    else
    {
        return false;
    }
}

void orderVertxPoints(std::vector<Point2>&vertxPoints,std::vector<Point2>&sortedVertx)
{
    // Delete dipulate elements
//    static double vertxMinX;
//    static double vertxMinY;

    std::sort(vertxPoints.begin(), vertxPoints.end(), sitesOrdered);
    sortedVertx.push_back(vertxPoints[0]);
    for (Point2& s : vertxPoints) 
    {
        if (s != sortedVertx.back())
        {
            sortedVertx.push_back(s);
        }
    }
    //compare cp;
    vertxMinX = sortedVertx[0].x;
    vertxMinY = sortedVertx[0].y;
//    bool vertxOrdered(const Point2 & s1, const Point2 & s2);
    std::sort(sortedVertx.begin(), sortedVertx.end(), vertxOrdered);
}

//Generate Voronoi form porous
void Porous2D::GenVoronoi(NXOpen::Part* workPart)
{
//    theSession->ListingWindow()->Open();
    //Set Voronoi parameters
    Porous2D::particleNumber = Porous2D::integerParticleNumber->Value();

    int sumVertxNum = 0;
    std::vector<double>sitesX;
    std::vector<double>sitesY;
    std::vector<Point2>sites;
    std::vector<Point2>vertxStart;
    std::vector<Point2>vertxEnd;
    std::vector<int> edgeNumber;
    genVertexPoints(sites, vertxStart, vertxEnd, edgeNumber); 
    std::vector<NXOpen::Scalar*> cellScalarX1;
    std::vector<NXOpen::Scalar*> cellScalarY1;
    std::vector<NXOpen::Scalar*> cellScalarZ1;
    std::vector<NXOpen::Point*> cellPoints;
    for (int i = 0; i < sites.size(); i++)
    {
        sitesX.push_back(sites[i].x);
        sitesY.push_back(sites[i].y);
    }
	UF_UI_write_listing_window("====================================================================\n");
    UF_UI_write_listing_window("==========================Voronoi Check ============================\n");
	UF_UI_write_listing_window("====================================================================\n");

    for (int cellIndx = 0; cellIndx < Porous2D::particleNumber; cellIndx++)
    {
        //Initialize StudioSplineBuilderEx tools
        NXOpen::NXObject* nullNXOpen_NXObject(NULL);
        NXOpen::Features::StudioSplineBuilderEx* studioSplineBuilderEx1;
        studioSplineBuilderEx1 = workPart->Features()->CreateStudioSplineBuilderEx(nullNXOpen_NXObject);
        //----Set reference plane
        NXOpen::Point3d origin1(0.0, 0.0, 0.0);
        NXOpen::Vector3d normal1(0.0, 0.0, 1.0);
        NXOpen::Plane* plane1;
        plane1 = workPart->Planes()->CreatePlane(origin1, normal1, NXOpen::SmartObject::UpdateOptionWithinModeling);
        studioSplineBuilderEx1->SetDrawingPlane(plane1);
        //----Set movement plane
        NXOpen::Point3d origin2(0.0, 0.0, 0.0);
        NXOpen::Vector3d normal2(0.0, 0.0, 1.0);
        NXOpen::Plane* plane2;
        plane2 = workPart->Planes()->CreatePlane(origin2, normal2, NXOpen::SmartObject::UpdateOptionWithinModeling);
        studioSplineBuilderEx1->SetMovementPlane(plane2);
        //Set spline parameters
        studioSplineBuilderEx1->OrientExpress()->SetReferenceOption(NXOpen::GeometricUtilities::OrientXpressBuilder::ReferenceWcsDisplayPart);
        studioSplineBuilderEx1->SetDrawingPlaneOption(NXOpen::Features::StudioSplineBuilderEx::DrawingPlaneOptionsXY);
        studioSplineBuilderEx1->SetMovementMethod(NXOpen::Features::StudioSplineBuilderEx::MovementMethodTypeView);
        studioSplineBuilderEx1->SetType(NXOpen::Features::StudioSplineBuilderEx::TypesByPoles);
        studioSplineBuilderEx1->SetDegree(Porous2D::integerBSplineOrder->Value());
        studioSplineBuilderEx1->SetPeriodic(true);
        studioSplineBuilderEx1->OrientExpress()->SetAxisOption(NXOpen::GeometricUtilities::OrientXpressBuilder::AxisPassive);
        studioSplineBuilderEx1->OrientExpress()->SetPlaneOption(NXOpen::GeometricUtilities::OrientXpressBuilder::PlanePassive);
        studioSplineBuilderEx1->SetInputCurveOption(NXOpen::Features::StudioSplineBuilderEx::InputCurveOptionsHide);
        studioSplineBuilderEx1->SetMatchKnotsType(NXOpen::Features::StudioSplineBuilderEx::MatchKnotsTypesNone);
        //Define GeometricConstraintData features for containning controlpoints
        std::vector<NXOpen::Features::GeometricConstraintData*> geometricConstraintData;
        //Set B spline controlpoints' definition
        std::vector<NXOpen::Scalar*> scalarX1;
        std::vector<NXOpen::Scalar*> scalarY1;
        std::vector<NXOpen::Scalar*> scalarZ1;
        std::vector<NXOpen::Point*> setPoints;
        //----Define temp parameters for B spline Scalars
        std::vector<double> xScalar;
        std::vector<double> yScalar;
        std::vector<double> zScalar;
        std::vector<Point2> vertxPoints;
        std::vector<Point2> sortedVertx;

        cellScalarX1.push_back(workPart->Scalars()->CreateScalar(sitesX[cellIndx], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
        cellScalarY1.push_back(workPart->Scalars()->CreateScalar(sitesY[cellIndx], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
        cellScalarZ1.push_back(workPart->Scalars()->CreateScalar(0.0, NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
        cellPoints.push_back(workPart->Points()->CreatePoint(cellScalarX1[cellIndx],cellScalarY1[cellIndx],cellScalarZ1[cellIndx],NXOpen::SmartObject::UpdateOptionWithinModeling));
        cellPoints[cellIndx]->SetVisibility(NXOpen::SmartObject::VisibilityOptionVisible);

        UF_UI_write_listing_window("-------------------------- cell info start -------------------------\n");
        char tempString[256];
        std::sprintf(tempString, "->\tCellIndex:%d\tCells' sites:(%f,%f)\n", cellIndx, sitesX[cellIndx], sitesY[cellIndx]);
        UF_UI_write_listing_window(tempString);
        std::sprintf(tempString, "->\tCells' edge number:%d\n", edgeNumber[cellIndx]);
        UF_UI_write_listing_window(tempString);
//        std::sprintf(tempString, "->\tCells' vertices number:%d\n", (int)(diagram->vertices.size()));
//        UF_UI_write_listing_window(tempString);
        if (edgeNumber[cellIndx] > 2)
        {
            for (int vertxIndx = 0; vertxIndx  < edgeNumber[cellIndx]; vertxIndx++)
            {
                vertxPoints.push_back(vertxStart[sumVertxNum + vertxIndx]);
                vertxPoints.push_back(vertxEnd[sumVertxNum + vertxIndx]);
            }
            orderVertxPoints(vertxPoints,sortedVertx);
            for (int vertxIndx = 0; vertxIndx  < edgeNumber[cellIndx]; vertxIndx++)
            {
////                xScalar.push_back(vertxPoints[sumVertxNum + vertxIndx].x);
////                yScalar.push_back(vertxPoints[sumVertxNum + vertxIndx].y);
////                zScalar.push_back(0.0);
                xScalar.push_back(sortedVertx[vertxIndx].x);
                yScalar.push_back(sortedVertx[vertxIndx].y);
                zScalar.push_back(0.0);
                std::sprintf(tempString, "->\tVertxIndex:%d\tvertxPoints:(%f,%f)\tsortedPoints:(%f,%f)\n", vertxIndx,vertxPoints[vertxIndx].x,vertxPoints[vertxIndx].y,xScalar[vertxIndx],yScalar[vertxIndx]);
                UF_UI_write_listing_window(tempString);
            }
        sumVertxNum = edgeNumber[cellIndx] + sumVertxNum;
        //Get set points
        for (int i = 0; i < edgeNumber[cellIndx]; i++)
        {
            scalarX1.push_back(workPart->Scalars()->CreateScalar(xScalar[i], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
            scalarY1.push_back(workPart->Scalars()->CreateScalar(yScalar[i], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
            scalarZ1.push_back(workPart->Scalars()->CreateScalar(zScalar[i], NXOpen::Scalar::DimensionalityTypeNone, NXOpen::SmartObject::UpdateOptionWithinModeling));
            setPoints.push_back(workPart->Points()->CreatePoint(scalarX1[i], scalarY1[i], scalarZ1[i], NXOpen::SmartObject::UpdateOptionWithinModeling));
            geometricConstraintData.push_back(studioSplineBuilderEx1->ConstraintManager()->CreateGeometricConstraintData());
            geometricConstraintData[i]->SetPoint(setPoints[i]);
            studioSplineBuilderEx1->ConstraintManager()->Append(geometricConstraintData[i]);
            studioSplineBuilderEx1->Evaluate();
        }
        //Commit parameters to build spline
        NXOpen::NXObject* nXObjectSpline;
        nXObjectSpline = studioSplineBuilderEx1->Commit();
        //----Get particle curves' objects
        Porous2D::particleObject.push_back(nXObjectSpline);
        //----Get particle curves' features
        Porous2D::splineFeature = dynamic_cast<NXOpen::Features::StudioSpline*>(nXObjectSpline);
        Porous2D::splineFeatureCollector.push_back(splineFeature);
        //Free memory
        studioSplineBuilderEx1->Destroy();
        }
    }
}

double normalize(double in, int dimension) {
	return in / (float)dimension*1.8 - 0.9;
}

void genRandomSites(std::vector<Point2>& sites, BoundingBox& bbox, unsigned int numSites) {
    std::vector<Point2> tmpSites;

    tmpSites.reserve(numSites);
    sites.reserve(numSites);

    Point2 s;

    srand(std::clock());
    for (unsigned int i = 0; i < numSites; ++i)
    {
        s.x = 1 + (rand() / (double)RAND_MAX) * ((bbox.xR-bbox.xL) - 2);
        s.y = 1 + (rand() / (double)RAND_MAX) * ((bbox.yT-bbox.yB) - 2);
        tmpSites.push_back(s);
    }
    //remove any duplicates that exist
    std::sort(tmpSites.begin(), tmpSites.end(), sitesOrdered);
    sites.push_back(tmpSites[0]);
    for (Point2& s : tmpSites) 
    {
        if (s != sites.back())
        {
            sites.push_back(s);
        }
    }
}

void Porous2D::genVertexPoints(std::vector<Point2>& sites, std::vector<Point2>& vertxStart,std::vector<Point2>&vertxEnd,std::vector<int>& edgeNumber)
{
	UF_UI_write_listing_window("====================================================================\n");
    UF_UI_write_listing_window("==========================Voronoi Compute===========================\n");
	UF_UI_write_listing_window("====================================================================\n");
	VoronoiDiagramGenerator vdg = VoronoiDiagramGenerator();
    Diagram* diagram = nullptr;
    double diamentionX0 = Porous2D::pointSheetStart->Point().X;
    double diamentionY0 = Porous2D::pointSheetStart->Point().Y;
    double diamentionXmax = Porous2D::expressionFaceLength->Value();
    double diamentionYmax = Porous2D::expressionFaceWidth->Value();

	BoundingBox bbox(diamentionX0,diamentionXmax,diamentionY0,diamentionYmax);
    unsigned int nPoints = Porous2D::integerParticleNumber->Value();
    std::vector<Point2> randSites;
    bool startOver = true;
    bool relaxForever = false;
    int relax = 0;
    Point2 startPoints;
    Point2 endPoints;
    if (startOver)
    {
    	genRandomSites(randSites, bbox, nPoints);
    	diagram = vdg.compute(randSites, bbox);
    }
    if (relax || relaxForever) 
    {
        Diagram* prevDiagram = diagram;
        diagram = vdg.relax();
        delete prevDiagram;
    
        if (diagram->cells.size() != 4) int x = 0;
        --relax;
        if (relax < 0) relax = 0;
    }

    UF_UI_write_listing_window("------------------------ diagram info start ------------------------\n");
    char tempString[256];
    std::sprintf(tempString, "->\tCells' number:%d\n", (int)(diagram->cells.size()));
    UF_UI_write_listing_window(tempString);
    std::sprintf(tempString, "->\tCells' edge number:%d\n", (int)(diagram->edges.size()));
    UF_UI_write_listing_window(tempString);
    std::sprintf(tempString, "->\tCells' vertices number:%d\n", (int)(diagram->vertices.size()));
    UF_UI_write_listing_window(tempString);
    int cellIndex= 0;
    for (Cell* c : diagram->cells)
    {
        Point2& p = c->site.p;
        sites.push_back(p);
        edgeNumber.push_back(c->halfEdges.size());
    	UF_UI_write_listing_window("------------------------- cells info start -------------------------\n");
        sprintf(tempString, "CellIndex:%d\tCells' sites:(%f,%f)\n", cellIndex, p.x, p.y);
        UF_UI_write_listing_window(tempString);
        sprintf(tempString, "->\tCells' halfedges' number:%d\n", (int)(c->halfEdges.size()));
        UF_UI_write_listing_window(tempString);
        for (HalfVoronoiEdge* ve : c->halfEdges)
        {
            startPoints.x = ve->edge->vertA->x;
            startPoints.y = ve->edge->vertA->y;
            endPoints.x = ve->edge->vertB->x;
            endPoints.y = ve->edge->vertB->y;
            vertxStart.push_back(startPoints);
            vertxEnd.push_back(endPoints);
            sprintf(tempString, "--->\tVertexBeginPoints:(%f,%f)\tVertexEndPoints:(%f,%f)\n", startPoints.x, startPoints.y, endPoints.x, endPoints.y);
            UF_UI_write_listing_window(tempString);
        }
     	UF_UI_write_listing_window("------------------------- cells info stop --------------------------\n");
        cellIndex++;
    }
    UF_UI_write_listing_window("------------------------ diagram info stop -------------------------\n");
    delete diagram;
}



#endif //POROUS2D_H_INCLUDED



////    	startOver = false;
////    	relaxForever = false;
////    	relax = 0;

////    	duration = 1000 * (std::clock() - start) / (double)CLOCKS_PER_SEC;
//    std::vector<NXOpen::Point *> sites;
//    if (relax || relaxForever) {
//    for (VoronoiEdge* e : diagram->edges)
//    {
//        if (e->vertA && e->vertB)
//        {
//            Point2& p1 = *e->vertA;
//            Point2& p2 = *e->vertB;
//            (*vertexX).push_back(p1.x);
//            (*vertexY).push_back(p1.y);
//        }
//    }

